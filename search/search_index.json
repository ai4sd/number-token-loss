{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Number Token Loss","text":"A regression-like loss that improves numerical reasoning in language models. Originally presented in \u201cRegress, Don\u2019t Guess\u201d (ICML 2025)."},{"location":"#getting-started","title":"Getting Started","text":"<p>Install from PyPI:</p> <pre><code>uv add ntloss\npip install ntloss # if you are oldschool\n</code></pre> <p>Use like this: <pre><code>from ntloss import NTLoss\nntl_fn = NTLoss(tokenizer=tokenizer)\nntl = ntl_fn(logits, labels)\n\n# We recommend\nloss = cross_entropy(logits, labels) + 0.3 * ntl\n</code></pre></p> <p><code>ntloss</code> is currently in alpha phase and pre-release. Feedback &amp; PRs are very welcome.</p>"},{"location":"#citation","title":"\ud83d\udcdd Citation","text":"<p>If you use <code>ntloss</code>, please cite our paper:</p> <pre><code>@inproceedings{zausinger2025regress,\n  title   = {Regress, Don't Guess \u2013 A Regression-like Loss on Number Tokens for Language Models},\n  author  = {Jonas Zausinger and Lars Pennig and Anamarija Kozina and Sean Sdahl\n             and Julian Sikora and Adrian Dendorfer and Timofey Kuznetsov\n             and Mohamad Hagog and Nina Wiedemann and Kacper Chlodny\n             and Vincent Limbach and Anna Ketteler and Thorben Prein\n             and Vishwa Mohan Singh and Michael Danziger and Jannis Born},\n  booktitle = {Proc. of the 42nd International Conference on Machine Learning (ICML)},\n  year    = {2025},\n  url     = {https://tum-ai.github.io/number-token-loss/}\n}\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#ntlosscore","title":"ntloss.core","text":""},{"location":"api/#ntloss.core","title":"<code>ntloss.core</code>","text":""},{"location":"api/#ntloss.core.AbstractNTLoss","title":"<code>AbstractNTLoss</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ntloss/core.py</code> <pre><code>class AbstractNTLoss(ABC):\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n    ):\n        \"\"\"\n        NTL constructor.\n\n        Args:\n            tokenizer: Standard HF tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n\n        \"\"\"\n        super().__init__()\n        self.tokenizer = tokenizer\n        self.vocab_size = vocab_size if vocab_size is not None else len(self.tokenizer)\n        self._vocab_size_validated = False\n        self.digit_level = digit_level\n        self.reweigh = reweigh\n\n        self.setup_number_tokens()\n\n        self.max_dist = torch.tensor(0.0)\n\n    def setup_number_tokens(self):\n        \"\"\"Setting up attributes needed by NT loss\"\"\"\n\n        # Add digits to vocab if not there yet.\n        vocab_size = len(self.tokenizer)\n        if self.digit_level:\n            new_tokens = self.tokenizer.add_tokens(list(map(str, range(10))))\n        if vocab_size &lt; len(self.tokenizer) and new_tokens &gt; 0:\n            logger.warning(f\"Added {new_tokens} new tokens for number token loss\")\n        vocab = self.tokenizer.get_vocab()\n        self.number_values: FloatTensor = torch.full((self.vocab_size,), float(\"nan\"))\n\n        # Try to convert each token to a float after stripping the space prefix\n        for token, id in vocab.items():\n            if is_number(token, finite=True):\n                if self.digit_level:\n                    # NOTE: This check ensures number token value only occurs for digits, not for multi-digit numbers (123)\n                    # This stabilizes training with NTL. Can be altered though, see paper experiments.\n                    # Excludes tokens that are numbers in other languages like \u1098 and tokens with space pre-/postfix like ` 2`.\n                    if token.isascii() and -1 &lt;= float(token) &lt;= 9 and len(token) == 1:\n                        self.number_values[id] = float(token)\n                else:\n                    self.number_values[id] = float(token)\n\n        self.is_number_token = ~torch.isnan(self.number_values)\n        if self.is_number_token.sum() == len(self.is_number_token):\n            raise ValueError(\n                \"At least one token needs to be not a number, otherwise `ignore_index` cannot be set up safely\"\n            )\n        self.nan_id = torch.where(~self.is_number_token)[0][0].item()\n        self.number_values_dense = self.number_values[self.is_number_token]\n\n        if self.digit_level and (num_nts := len(self.number_values_dense)) != 10:\n            logger.error(\n                f\"You requested digit-level but {num_nts} number tokens were identified: {self.number_values_dense}\"\n            )\n        self.number_token_ids = torch.nonzero(\n            self.is_number_token, as_tuple=False\n        ).squeeze(1)\n        self._nt_ids_cache: dict[torch.device, torch.Tensor] = {}\n\n    @abstractmethod\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n    ) -&gt; Tensor: ...\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Alias to self.forward\"\"\"\n        return self.forward(*args, **kwargs)\n\n    def reweigh_fn(\n        self,\n        logits: Tensor,\n        loss: Tensor,\n        number_token_positions: Tensor,\n    ) -&gt; Tensor:\n        \"\"\"\n        Scale the NT loss element-wise using the logit weight on number tokens.\n        NOTE: This reweighing ensures that if ground truth is a number token\n            but most probability mass is on text tokens, the loss will be *higher*\n            than the worst possible number token. Mostly to accelerate early training.\n        NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            loss: 1D Tensor over all number tokens in batch.\n            number_token_positions: 2D Tensor of shape BS x T indicating for which tokens\n                the NT loss was computed.\n\n        Returns:\n            A 1D Tensor over all number tokens in batch with the scaled NT losses.\n        \"\"\"\n\n        nt_logits = logits[number_token_positions]\n        nt_ids = self._nt_ids_cache.get(nt_logits.device)\n        if nt_ids is None:\n            nt_ids = self.number_token_ids.to(nt_logits.device)\n            self._nt_ids_cache[nt_logits.device] = nt_ids\n\n        # Softmax and mass only for relevant positions\n        nt_probs = torch.softmax(nt_logits, dim=-1)  # (K, V)\n        nt_mass = nt_probs.index_select(dim=-1, index=nt_ids).sum(dim=-1)\n\n        # Apply regularization (in place is faster)\n        loss.mul_(nt_mass)\n        # NOTE: We could consider reweighing here with the max for that label token\n        # rather than the global max\n        loss.add_(\n            1.01\n            * self.max_dist.to(dtype=loss.dtype, device=loss.device)\n            * (1 - nt_mass)\n        )\n        return loss\n\n    def _validate_inputs(\n        self,\n        logits: FloatTensor,\n        labels: Optional[LongTensor],\n        loss_weights: Optional[Tensor],\n    ):\n        \"\"\"Private method to perform size and type checks.\"\"\"\n        if (td := len(logits.shape)) != 3 or logits.numel() == 0:\n            raise ValueError(\n                f\"Logits have to be non-empty 3D Tensor, not {td}D with {logits.numel()} elements\"\n            )\n        if not torch.is_floating_point(logits):\n            raise TypeError(\"Logits have to be FloatTensor.\")\n        if labels is None:\n            return\n        if not labels.dtype == torch.long:\n            raise TypeError(f\"Labels have to be LongTensor, not {type(labels)}\")\n        if (b := labels.shape) != (a := logits.shape[:-1]):\n            raise ValueError(\n                f\"Logit and label sizes of first 2 dims have to match: {a} vs {b}\"\n            )\n\n        if (td := len(labels.shape)) != 2 or labels.numel() == 0:\n            raise ValueError(\n                f\"Labels have to be non-empty 2D Tensor, not {td}D with {labels.numel()} elements\"\n            )\n        if loss_weights is not None:\n            if loss_weights.shape != labels.shape:\n                raise ValueError(\n                    \"Loss mask has to be 2D Tensor of same shape as labels.\"\n                )\n            if torch.any(loss_weights &lt; 0):\n                raise ValueError(\"loss_mask must be \u2265 0.\")\n\n        if not self._vocab_size_validated:\n            logits_vocab_size = logits.shape[-1]\n            if logits_vocab_size != self.vocab_size:\n                raise ValueError(\n                    f\"The current `vocab_size` ({self.vocab_size}) does not match the model's vocab size\"\n                    f\"logit dimension ({logits_vocab_size}). Please check the value.\"\n                )\n            self._vocab_size_validated = True\n\n    def _prepare_number_token_targets(\n        self, labels: LongTensor, loss_weights: Optional[Tensor], ignore_index: int\n    ) -&gt; Tuple[FloatTensor, Tensor]:\n        \"\"\"\n        Prepare number-token targets and masks.\n\n        Args:\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: Optional 2D Tensor of shape BS x T with loss weight for each token.\n            ignore_index: Label ID to ignore. Defaults to -100.\n\n        Returns:\n            y: 2D Float Tensor of shape BS x T with target numeric values (NaN for non-number tokens).\n            loss_weight: 1D Tensor with a potentially individual loss weight for each number token position.\n        \"\"\"\n        labels = cast(\n            LongTensor, labels.masked_fill(labels == ignore_index, self.nan_id)\n        )\n        # Create a mask to filter out non-digit tokens\n        y = self.number_values.to(device=labels.device)[labels]\n        number_token_positions = ~torch.isnan(y)\n        loss_weights = (\n            loss_weights[number_token_positions]\n            if loss_weights is not None\n            else torch.ones_like(labels, device=labels.device)[number_token_positions]\n        )\n        return cast(FloatTensor, y), loss_weights\n\n    @staticmethod\n    def _apply_reduction(\n        loss: Tensor,\n        reduction: str,\n        loss_weights: Tensor,\n        number_token_positions: Tensor,\n        logits: Tensor,\n    ) -&gt; Tensor:\n        \"\"\"\n        Applies the specified reduction type to the calculated loss.\n\n        This method handles 3 types of reduction: \"mean\", \"sum\", and \"none\".\n        For \"mean\" and \"sum\", it applies weighting using `loss_weights`.\n        For \"none\", it reshapes the loss back to the original batch and sequence\n        dimensions.\n\n        Args:\n            loss: 1D Tensor containing the loss for each number token in the batch.\n            reduction: The reduction method (\"mean\", \"sum\", or \"none\").\n            loss_weights: 1D Tensor with a loss weight for each number token.\n            number_token_positions: 2D boolean tensor of shape BS x T indicating\n                the positions of number tokens.\n            logits: 3D Tensor of shape BS x T x V, used to get the original shape\n                for the \"none\" reduction.\n\n        Returns:\n            A Tensor representing the reduced loss:\n                - 0D tensor if `reduction` is \"mean\" or \"sum\".\n                - 2D Tensor of shape BS x T if `reduction` is \"none\".\n        \"\"\"\n        loss_weights = loss_weights.to(device=loss.device, dtype=loss.dtype)\n        if reduction == \"mean\":\n            # Mean pooling (weighted by loss mask)\n            loss = torch.dot(\n                loss.flatten(), loss_weights.flatten()\n            ) / loss_weights.sum().clamp_min(torch.finfo(loss.dtype).eps)\n        elif reduction == \"sum\":\n            loss = torch.dot(loss.flatten(), loss_weights.flatten())\n        elif reduction == \"none\":\n            # Cast loss for number tokens back to Tensor of size BS x T\n            loss_ = torch.zeros(number_token_positions.numel()).to(loss.device)\n            loss_[number_token_positions.view(-1)] = loss * loss_weights\n            bs, seq_len, _ = logits.size()\n            loss = loss_.view(bs, seq_len)\n\n            assert torch.sum(loss[~number_token_positions]) == 0, (\n                \"NumberTokenLoss computed for non-digit tokens!\"\n            )\n\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n</code></pre>"},{"location":"api/#ntloss.core.AbstractNTLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True)</code>","text":"<p>NTL constructor.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Standard HF tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n):\n    \"\"\"\n    NTL constructor.\n\n    Args:\n        tokenizer: Standard HF tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n\n    \"\"\"\n    super().__init__()\n    self.tokenizer = tokenizer\n    self.vocab_size = vocab_size if vocab_size is not None else len(self.tokenizer)\n    self._vocab_size_validated = False\n    self.digit_level = digit_level\n    self.reweigh = reweigh\n\n    self.setup_number_tokens()\n\n    self.max_dist = torch.tensor(0.0)\n</code></pre>"},{"location":"api/#ntloss.core.AbstractNTLoss.setup_number_tokens","title":"<code>setup_number_tokens()</code>","text":"<p>Setting up attributes needed by NT loss</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_number_tokens(self):\n    \"\"\"Setting up attributes needed by NT loss\"\"\"\n\n    # Add digits to vocab if not there yet.\n    vocab_size = len(self.tokenizer)\n    if self.digit_level:\n        new_tokens = self.tokenizer.add_tokens(list(map(str, range(10))))\n    if vocab_size &lt; len(self.tokenizer) and new_tokens &gt; 0:\n        logger.warning(f\"Added {new_tokens} new tokens for number token loss\")\n    vocab = self.tokenizer.get_vocab()\n    self.number_values: FloatTensor = torch.full((self.vocab_size,), float(\"nan\"))\n\n    # Try to convert each token to a float after stripping the space prefix\n    for token, id in vocab.items():\n        if is_number(token, finite=True):\n            if self.digit_level:\n                # NOTE: This check ensures number token value only occurs for digits, not for multi-digit numbers (123)\n                # This stabilizes training with NTL. Can be altered though, see paper experiments.\n                # Excludes tokens that are numbers in other languages like \u1098 and tokens with space pre-/postfix like ` 2`.\n                if token.isascii() and -1 &lt;= float(token) &lt;= 9 and len(token) == 1:\n                    self.number_values[id] = float(token)\n            else:\n                self.number_values[id] = float(token)\n\n    self.is_number_token = ~torch.isnan(self.number_values)\n    if self.is_number_token.sum() == len(self.is_number_token):\n        raise ValueError(\n            \"At least one token needs to be not a number, otherwise `ignore_index` cannot be set up safely\"\n        )\n    self.nan_id = torch.where(~self.is_number_token)[0][0].item()\n    self.number_values_dense = self.number_values[self.is_number_token]\n\n    if self.digit_level and (num_nts := len(self.number_values_dense)) != 10:\n        logger.error(\n            f\"You requested digit-level but {num_nts} number tokens were identified: {self.number_values_dense}\"\n        )\n    self.number_token_ids = torch.nonzero(\n        self.is_number_token, as_tuple=False\n    ).squeeze(1)\n    self._nt_ids_cache: dict[torch.device, torch.Tensor] = {}\n</code></pre>"},{"location":"api/#ntloss.core.AbstractNTLoss.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Alias to self.forward</p> Source code in <code>ntloss/core.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    \"\"\"Alias to self.forward\"\"\"\n    return self.forward(*args, **kwargs)\n</code></pre>"},{"location":"api/#ntloss.core.AbstractNTLoss.reweigh_fn","title":"<code>reweigh_fn(logits: Tensor, loss: Tensor, number_token_positions: Tensor) -&gt; Tensor</code>","text":"<p>Scale the NT loss element-wise using the logit weight on number tokens. NOTE: This reweighing ensures that if ground truth is a number token     but most probability mass is on text tokens, the loss will be higher     than the worst possible number token. Mostly to accelerate early training. NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>Tensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>loss</code> <code>Tensor</code> <p>1D Tensor over all number tokens in batch.</p> required <code>number_token_positions</code> <code>Tensor</code> <p>2D Tensor of shape BS x T indicating for which tokens the NT loss was computed.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A 1D Tensor over all number tokens in batch with the scaled NT losses.</p> Source code in <code>ntloss/core.py</code> <pre><code>def reweigh_fn(\n    self,\n    logits: Tensor,\n    loss: Tensor,\n    number_token_positions: Tensor,\n) -&gt; Tensor:\n    \"\"\"\n    Scale the NT loss element-wise using the logit weight on number tokens.\n    NOTE: This reweighing ensures that if ground truth is a number token\n        but most probability mass is on text tokens, the loss will be *higher*\n        than the worst possible number token. Mostly to accelerate early training.\n    NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        loss: 1D Tensor over all number tokens in batch.\n        number_token_positions: 2D Tensor of shape BS x T indicating for which tokens\n            the NT loss was computed.\n\n    Returns:\n        A 1D Tensor over all number tokens in batch with the scaled NT losses.\n    \"\"\"\n\n    nt_logits = logits[number_token_positions]\n    nt_ids = self._nt_ids_cache.get(nt_logits.device)\n    if nt_ids is None:\n        nt_ids = self.number_token_ids.to(nt_logits.device)\n        self._nt_ids_cache[nt_logits.device] = nt_ids\n\n    # Softmax and mass only for relevant positions\n    nt_probs = torch.softmax(nt_logits, dim=-1)  # (K, V)\n    nt_mass = nt_probs.index_select(dim=-1, index=nt_ids).sum(dim=-1)\n\n    # Apply regularization (in place is faster)\n    loss.mul_(nt_mass)\n    # NOTE: We could consider reweighing here with the max for that label token\n    # rather than the global max\n    loss.add_(\n        1.01\n        * self.max_dist.to(dtype=loss.dtype, device=loss.device)\n        * (1 - nt_mass)\n    )\n    return loss\n</code></pre>"},{"location":"api/#ntloss.core.NTLossDotProduct","title":"<code>NTLossDotProduct</code>","text":"<p>               Bases: <code>AbstractNTLoss</code></p> <p>Class for NT losses that produce a token-wise numerical output.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NTLossDotProduct(AbstractNTLoss):\n    \"\"\"Class for NT losses that produce a token-wise numerical output.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n        loss_function: Callable = F.mse_loss,\n    ):\n        \"\"\"\n        Referred to as NTL-L_p in the paper.\n\n        Args:\n            tokenizer: NTLTokenizer with necessary attributes like is_number_token etc.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n            loss_function: Function to apply on the delta between the ground truth number\n                and the obtained dot product (nt-probs * token-values). Defaults to\n                MSE, but MAE, Huber etc are also compatible.\n        \"\"\"\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=digit_level,\n            reweigh=reweigh,\n        )\n        self.loss_function = loss_function\n        self.setup_max_dist()\n\n    def setup_max_dist(self):\n        \"\"\"\n        Set up the maximum distance between the number tokens based on the selected loss function.\n        \"\"\"\n\n        # Extract the number token values and get the minimum and maximum\n        vals = self.number_values_dense.unsqueeze(0)\n        max_val = vals.max()\n        min_val = vals.min()\n\n        # Compute the largest value the loss function used in NT loss computation can get\n        # Make sure to account for possibility of asymmetrical loss function\n        self.max_dist = torch.maximum(\n            torch.abs(self.loss_function(min_val, max_val)),\n            torch.abs(self.loss_function(max_val, min_val)),\n        )\n\n    def predict_numbers(self, logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]:\n        \"\"\"\n        Calculates token-level numerical prediction.\n        NOTE: This calculates numerical predictions for *all* tokens, not just where\n        label is a number token.\n\n        Args:\n            logits: 3D FloatTensor of shape BS x T x V.\n\n        Returns:\n            yhat: 2D FloatTensor BS x T containing numerical predictions.\n            nt_mass: 2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.\n        \"\"\"\n        self._validate_inputs(logits, labels=None, loss_weights=None)\n\n        # Calculate the token-level predictions\n        yhat = self._get_dot_product(logits=logits)\n\n        probs_all = F.softmax(logits, dim=-1)\n        probs_nt = probs_all[:, :, self.is_number_token]\n        nt_mass = probs_nt.sum(dim=-1)\n        return yhat, cast(FloatTensor, nt_mass)\n\n    def _get_dot_product(\n        self, logits: FloatTensor, number_token_positions: Optional[BoolTensor] = None\n    ) -&gt; FloatTensor:\n        \"\"\"\n        Applies dot product of number token values and their predicted probabilites.\n\n        Args:\n            logits: 3D FloatTensor of shape BS x T x V.\n            number_token_positions: Optional 2D BoolTensor (BS x T) containing locations\n                of number tokens.\n\n        Returns:\n            If `number_token_positions` is None, 2D FloatTensor of shape BS x T.\n            Otherwise, 1D FloatTensor containing the predictions for the number tokens.\n        \"\"\"\n        # apply softmax solely over the number token indices\n        nt_logits = logits[:, :, self.is_number_token]\n        softmax_probs = F.softmax(nt_logits, dim=-1)\n        values = self.number_values_dense.to(device=logits.device, dtype=logits.dtype)\n\n        # compute the weighted average of number tokens\n        if number_token_positions is None:\n            # Calculate for all tokens\n            yhat = torch.sum(softmax_probs * values, dim=-1)\n        else:\n            # Calculate selectively where labels are number tokens\n            yhat = torch.sum(softmax_probs[number_token_positions] * values, dim=-1)\n        return cast(FloatTensor, yhat)\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL based on the dot product between token values and their probs.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                OD if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, loss_weights = self._prepare_number_token_targets(\n            labels, loss_weights, ignore_index\n        )\n        loss_weights = loss_weights.to(logits.dtype)\n        number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n        # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or not loss_weights.any():\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(\n                    labels, dtype=logits.dtype, device=labels.device\n                )\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        yhat = self._get_dot_product(\n            logits=logits, number_token_positions=number_token_positions\n        )\n\n        # Apply specified loss function to y and yhat\n        loss = self.loss_function(yhat, y[number_token_positions], reduction=\"none\")\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/#ntloss.core.NTLossDotProduct.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True, loss_function: Callable = F.mse_loss)</code>","text":"<p>Referred to as NTL-L_p in the paper.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>NTLTokenizer with necessary attributes like is_number_token etc.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> <code>loss_function</code> <code>Callable</code> <p>Function to apply on the delta between the ground truth number and the obtained dot product (nt-probs * token-values). Defaults to MSE, but MAE, Huber etc are also compatible.</p> <code>mse_loss</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n    loss_function: Callable = F.mse_loss,\n):\n    \"\"\"\n    Referred to as NTL-L_p in the paper.\n\n    Args:\n        tokenizer: NTLTokenizer with necessary attributes like is_number_token etc.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n        loss_function: Function to apply on the delta between the ground truth number\n            and the obtained dot product (nt-probs * token-values). Defaults to\n            MSE, but MAE, Huber etc are also compatible.\n    \"\"\"\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=digit_level,\n        reweigh=reweigh,\n    )\n    self.loss_function = loss_function\n    self.setup_max_dist()\n</code></pre>"},{"location":"api/#ntloss.core.NTLossDotProduct.setup_max_dist","title":"<code>setup_max_dist()</code>","text":"<p>Set up the maximum distance between the number tokens based on the selected loss function.</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_max_dist(self):\n    \"\"\"\n    Set up the maximum distance between the number tokens based on the selected loss function.\n    \"\"\"\n\n    # Extract the number token values and get the minimum and maximum\n    vals = self.number_values_dense.unsqueeze(0)\n    max_val = vals.max()\n    min_val = vals.min()\n\n    # Compute the largest value the loss function used in NT loss computation can get\n    # Make sure to account for possibility of asymmetrical loss function\n    self.max_dist = torch.maximum(\n        torch.abs(self.loss_function(min_val, max_val)),\n        torch.abs(self.loss_function(max_val, min_val)),\n    )\n</code></pre>"},{"location":"api/#ntloss.core.NTLossDotProduct.predict_numbers","title":"<code>predict_numbers(logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]</code>","text":"<p>Calculates token-level numerical prediction. NOTE: This calculates numerical predictions for all tokens, not just where label is a number token.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D FloatTensor of shape BS x T x V.</p> required <p>Returns:</p> Name Type Description <code>yhat</code> <code>FloatTensor</code> <p>2D FloatTensor BS x T containing numerical predictions.</p> <code>nt_mass</code> <code>FloatTensor</code> <p>2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.</p> Source code in <code>ntloss/core.py</code> <pre><code>def predict_numbers(self, logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]:\n    \"\"\"\n    Calculates token-level numerical prediction.\n    NOTE: This calculates numerical predictions for *all* tokens, not just where\n    label is a number token.\n\n    Args:\n        logits: 3D FloatTensor of shape BS x T x V.\n\n    Returns:\n        yhat: 2D FloatTensor BS x T containing numerical predictions.\n        nt_mass: 2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.\n    \"\"\"\n    self._validate_inputs(logits, labels=None, loss_weights=None)\n\n    # Calculate the token-level predictions\n    yhat = self._get_dot_product(logits=logits)\n\n    probs_all = F.softmax(logits, dim=-1)\n    probs_nt = probs_all[:, :, self.is_number_token]\n    nt_mass = probs_nt.sum(dim=-1)\n    return yhat, cast(FloatTensor, nt_mass)\n</code></pre>"},{"location":"api/#ntloss.core.NTLossDotProduct.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL based on the dot product between token values and their probs.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>2D Optional tensor of BS x T with token-wise loss weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor OD if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL based on the dot product between token values and their probs.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            OD if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, loss_weights = self._prepare_number_token_targets(\n        labels, loss_weights, ignore_index\n    )\n    loss_weights = loss_weights.to(logits.dtype)\n    number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n    # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or not loss_weights.any():\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(\n                labels, dtype=logits.dtype, device=labels.device\n            )\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    yhat = self._get_dot_product(\n        logits=logits, number_token_positions=number_token_positions\n    )\n\n    # Apply specified loss function to y and yhat\n    loss = self.loss_function(yhat, y[number_token_positions], reduction=\"none\")\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/#ntloss.core.NTLoss","title":"<code>NTLoss</code>","text":"<p>               Bases: <code>AbstractNTLoss</code></p> <p>Class for Wasserstein-based NTLoss. This is the default in the ICML paper.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NTLoss(AbstractNTLoss):\n    \"\"\"Class for Wasserstein-based NTLoss. This is the default in the ICML paper.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n        squash_factor: Optional[float] = None,\n    ):\n        \"\"\"\n        NTL constructor for the Wasserstein-based NTLoss.\n\n        Args:\n            tokenizer: Any HuggingFace tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n            squash_factor: The optional squashing factor for the NTL. If provided,\n                this number denotes the factor by which predicting the largest number\n                token is worse than predicting the closest incorrect number token.\n                E.g., with digit-level tokenization this factor is 9. Setting this\n                to 1 will recover cross entropy. This argument is intended to handle\n                irregular vocabs with large numerical token values.\n        \"\"\"\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=digit_level,\n            reweigh=reweigh,\n        )\n\n        self.squash_factor = squash_factor\n        self.setup_distance_lookup(squash_factor)\n\n    def setup_distance_lookup(\n        self,\n        squash_factor: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"\n        Set up a lookup table for the distances between the number tokens.\n        Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token.\n        If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9.\n        NOTE: With a squashing factor of 1, this basically collapses to cross entropy.\n\n        Args:\n            squash_factor: The optional squashing factor used.\n        \"\"\"\n\n        # Get token ids for number tokens\n        num_ids = torch.nonzero(self.is_number_token, as_tuple=True)[0]\n        # Create mapping from number token ids to their index in order of appearance in vocab:\n        # e.g. token \"3\" -&gt; id 519 -&gt; dist_idx 1, then abs dist to 3 for other NT values will be found in row/column 1\n        vocab_to_dist_idx = torch.full((self.vocab_size,), -1, dtype=torch.long)\n        # Use arange to ensure order of appearance\n        vocab_to_dist_idx[num_ids] = torch.arange(num_ids.size(0), dtype=torch.long)\n\n        # Build NxN abs-diff matrix\n        vals = self.number_values_dense.unsqueeze(0)  # (1 x N)\n        diff = torch.abs(vals - vals.t())  # (N x N)\n\n        if isinstance(squash_factor, Number):\n            assert squash_factor &gt; 1, (\n                f\"The squash factor can't be equal to or smaller than 1, please use a different squashing factor than {squash_factor}\"\n            )\n\n            # Mask out zeros to find the smallest nonzero diff\n            inf = torch.finfo(diff.dtype).max\n            diff_nonzero = diff.masked_fill(diff == 0, inf)\n            global_min_nz = diff_nonzero.min()\n            # Find largest diff\n            global_max = diff.max()\n\n            # Compute scaling factor based on indicated squash factor\n            scale = (squash_factor - 1) / (global_max - global_min_nz)\n            # Scale the absolute differences using scaling factor\n            lookup = 1 + (diff - global_min_nz) * scale\n            lookup[diff == 0] = 0.0\n\n        else:\n            lookup = diff\n\n        self.vocab_to_dist_idx = vocab_to_dist_idx\n        self.dist_lookup = lookup\n        self.max_dist = lookup.max()\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: Optional 2D tensor of BS x T with token-specific weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                OD if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, loss_weights = self._prepare_number_token_targets(\n            labels, loss_weights, ignore_index\n        )\n        loss_weights = loss_weights.to(logits.dtype)\n        number_token_positions = ~torch.isnan(y)\n\n        # If no digit tokens in batch, or total of the relevant loss_weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or not loss_weights.any():\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(\n                    labels, dtype=logits.dtype, device=labels.device\n                )\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        # apply softmax and get number labels\n        nt_logits = logits[:, :, self.is_number_token]\n        softmax_probs = F.softmax(nt_logits, dim=-1)\n\n        # get distance between the true numbers and all possible number values from lookup table\n        abs_diff = self.dist_lookup.to(dtype=logits.dtype, device=logits.device)[\n            self.vocab_to_dist_idx.to(device=labels.device)[\n                labels[number_token_positions]\n            ]\n        ]\n\n        # loss is the absolute difference weighted by the softmax probs\n        loss = (abs_diff * softmax_probs[number_token_positions]).sum(dim=-1)\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/#ntloss.core.NTLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True, squash_factor: Optional[float] = None)</code>","text":"<p>NTL constructor for the Wasserstein-based NTLoss.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Any HuggingFace tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> <code>squash_factor</code> <code>Optional[float]</code> <p>The optional squashing factor for the NTL. If provided, this number denotes the factor by which predicting the largest number token is worse than predicting the closest incorrect number token. E.g., with digit-level tokenization this factor is 9. Setting this to 1 will recover cross entropy. This argument is intended to handle irregular vocabs with large numerical token values.</p> <code>None</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n    squash_factor: Optional[float] = None,\n):\n    \"\"\"\n    NTL constructor for the Wasserstein-based NTLoss.\n\n    Args:\n        tokenizer: Any HuggingFace tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n        squash_factor: The optional squashing factor for the NTL. If provided,\n            this number denotes the factor by which predicting the largest number\n            token is worse than predicting the closest incorrect number token.\n            E.g., with digit-level tokenization this factor is 9. Setting this\n            to 1 will recover cross entropy. This argument is intended to handle\n            irregular vocabs with large numerical token values.\n    \"\"\"\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=digit_level,\n        reweigh=reweigh,\n    )\n\n    self.squash_factor = squash_factor\n    self.setup_distance_lookup(squash_factor)\n</code></pre>"},{"location":"api/#ntloss.core.NTLoss.setup_distance_lookup","title":"<code>setup_distance_lookup(squash_factor: Optional[float] = None) -&gt; None</code>","text":"<p>Set up a lookup table for the distances between the number tokens. Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token. If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9. NOTE: With a squashing factor of 1, this basically collapses to cross entropy.</p> <p>Parameters:</p> Name Type Description Default <code>squash_factor</code> <code>Optional[float]</code> <p>The optional squashing factor used.</p> <code>None</code> Source code in <code>ntloss/core.py</code> <pre><code>def setup_distance_lookup(\n    self,\n    squash_factor: Optional[float] = None,\n) -&gt; None:\n    \"\"\"\n    Set up a lookup table for the distances between the number tokens.\n    Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token.\n    If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9.\n    NOTE: With a squashing factor of 1, this basically collapses to cross entropy.\n\n    Args:\n        squash_factor: The optional squashing factor used.\n    \"\"\"\n\n    # Get token ids for number tokens\n    num_ids = torch.nonzero(self.is_number_token, as_tuple=True)[0]\n    # Create mapping from number token ids to their index in order of appearance in vocab:\n    # e.g. token \"3\" -&gt; id 519 -&gt; dist_idx 1, then abs dist to 3 for other NT values will be found in row/column 1\n    vocab_to_dist_idx = torch.full((self.vocab_size,), -1, dtype=torch.long)\n    # Use arange to ensure order of appearance\n    vocab_to_dist_idx[num_ids] = torch.arange(num_ids.size(0), dtype=torch.long)\n\n    # Build NxN abs-diff matrix\n    vals = self.number_values_dense.unsqueeze(0)  # (1 x N)\n    diff = torch.abs(vals - vals.t())  # (N x N)\n\n    if isinstance(squash_factor, Number):\n        assert squash_factor &gt; 1, (\n            f\"The squash factor can't be equal to or smaller than 1, please use a different squashing factor than {squash_factor}\"\n        )\n\n        # Mask out zeros to find the smallest nonzero diff\n        inf = torch.finfo(diff.dtype).max\n        diff_nonzero = diff.masked_fill(diff == 0, inf)\n        global_min_nz = diff_nonzero.min()\n        # Find largest diff\n        global_max = diff.max()\n\n        # Compute scaling factor based on indicated squash factor\n        scale = (squash_factor - 1) / (global_max - global_min_nz)\n        # Scale the absolute differences using scaling factor\n        lookup = 1 + (diff - global_min_nz) * scale\n        lookup[diff == 0] = 0.0\n\n    else:\n        lookup = diff\n\n    self.vocab_to_dist_idx = vocab_to_dist_idx\n    self.dist_lookup = lookup\n    self.max_dist = lookup.max()\n</code></pre>"},{"location":"api/#ntloss.core.NTLoss.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>Optional 2D tensor of BS x T with token-specific weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor OD if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: Optional 2D tensor of BS x T with token-specific weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            OD if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, loss_weights = self._prepare_number_token_targets(\n        labels, loss_weights, ignore_index\n    )\n    loss_weights = loss_weights.to(logits.dtype)\n    number_token_positions = ~torch.isnan(y)\n\n    # If no digit tokens in batch, or total of the relevant loss_weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or not loss_weights.any():\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(\n                labels, dtype=logits.dtype, device=labels.device\n            )\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    # apply softmax and get number labels\n    nt_logits = logits[:, :, self.is_number_token]\n    softmax_probs = F.softmax(nt_logits, dim=-1)\n\n    # get distance between the true numbers and all possible number values from lookup table\n    abs_diff = self.dist_lookup.to(dtype=logits.dtype, device=logits.device)[\n        self.vocab_to_dist_idx.to(device=labels.device)[\n            labels[number_token_positions]\n        ]\n    ]\n\n    # loss is the absolute difference weighted by the softmax probs\n    loss = (abs_diff * softmax_probs[number_token_positions]).sum(dim=-1)\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/#ntloss.core.NumberLevelLoss","title":"<code>NumberLevelLoss</code>","text":"<p>               Bases: <code>NTLossDotProduct</code></p> <p>Calculate NTL on a per-number (rather than per-token) basis.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NumberLevelLoss(NTLossDotProduct):\n    \"\"\"Calculate NTL on a per-number (rather than per-token) basis.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        float_level: bool = False,\n        reweigh: bool = True,\n        max_number_length: int = 20,\n    ):\n        \"\"\"\n        NTL constructor for the number-level NTLoss.\n\n        Args:\n            tokenizer: Any HuggingFace tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            float_level: Whether to calculate the loss for every float or every\n                integer in the sequence. For `12.34`, if float_level=False, two\n                loss terms will be calculated, respectively for `12` and `34`.\n                If float_level=True, a single `.` does not break the contiguity\n                of the identified number. Defaults to False.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n                Using this will explode the NL-NTL in the current implementation,\n                so reweighing for the NL-NTL needs to be refined.\n            max_number_length: Maximum expected length of a number in tokens.\n                Used for precomputing power masks. Defaults to 20.\n\n        \"\"\"\n        # digit_level must be set to True.\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=True,\n            reweigh=reweigh,\n            loss_function=F.l1_loss,  # unused\n        )\n        self.float_level = float_level\n        dot_result = self.tokenizer.convert_tokens_to_ids(\".\")\n        # Ensure we get an int, not a list\n        self.dot: int = dot_result if isinstance(dot_result, int) else dot_result[0]\n\n        # Precompute powers of 10 for efficiency\n        self.max_number_length = max_number_length\n        self.powers_of_10 = torch.pow(\n            10.0, torch.arange(max_number_length, dtype=torch.float32)\n        )\n\n    def setup_max_dist(self):\n        \"\"\"\n        Due to the MAPE loss calculation, the max dist is limited to 1.0\n        \"\"\"\n        self.max_dist = torch.tensor(1.0)\n\n    def convert_digits_to_numbers(\n        self,\n        y: FloatTensor,\n        yhat: FloatTensor,\n        number_token_positions: BoolTensor,\n        labels: LongTensor,\n    ):\n        \"\"\"\n        Vectorized conversion of digit-level number tokens to number-level values.\n\n        Output convention:\n        - Only the *first digit* of each detected number span contains the full number.\n        - All other digits (and in float_level=True also the dot token) inside the span\n            are set to NaN and removed from number_token_positions.\n        - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\")\n        - float_level=True : a single '.' between digits is part of the span but contributes 0\n                            (12.34 -&gt; \"1234\" as integer-like concatenation)\n\n        Args:\n            y: (B, T) float, GT digit values at digit positions, NaN elsewhere\n            yhat: (B, T) float, predicted digit values at all positions\n            number_token_positions: (B, T) bool, True at digit positions\n            labels: (B, T) long, token ids\n\n        Returns:\n            (y_new, yhat_new, number_token_positions_new) at number-level\n        \"\"\"\n        B, T = y.shape\n        device = y.device\n        is_digit = number_token_positions  # (B, T)\n        if not is_digit.any():\n            return y, yhat, number_token_positions\n\n        # -------------------------------------------------------------------------\n        # 1) Decide which tokens are considered \"inside a number span\"\n        # -------------------------------------------------------------------------\n        # Base: digits are always in spans\n        in_number: BoolTensor = is_digit\n\n        if self.float_level:\n            is_dot = labels.eq(self.dot)  # (B, T)\n\n            # dot is part of a number span only if it is *between* digits: d . d\n            digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n            digit_prev[:, 1:] = is_digit[:, :-1]\n\n            digit_next = torch.zeros((B, T), dtype=torch.bool, device=device)\n            digit_next[:, :-1] = is_digit[:, 1:]\n\n            dot_between_digits = is_dot &amp; digit_prev &amp; digit_next\n\n            # In float mode, those dots count as \"in number\" (but contribute 0 later)\n            in_number = cast(BoolTensor, in_number | dot_between_digits)\n        else:\n            dot_between_digits = torch.zeros((B, T), dtype=torch.bool, device=device)\n\n        # -------------------------------------------------------------------------\n        # 2) Build a \"continuation\" mask: does position t continue a span from t-1?\n        # -------------------------------------------------------------------------\n        # If previous token is a digit =&gt; continuation for digits (and for dot-between-digits in float mode)\n        digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_prev[:, 1:] = is_digit[:, :-1]\n\n        if self.float_level:\n            is_dot = labels.eq(self.dot)\n\n            dot_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n            dot_prev[:, 1:] = is_dot[:, :-1]\n\n            digit_prev2 = torch.zeros((B, T), dtype=torch.bool, device=device)\n            if T &gt; 2:\n                digit_prev2[:, 2:] = is_digit[:, :-2]\n\n            # Continue if:\n            #  - previous is digit, OR\n            #  - previous is dot and the token before that is digit (digit . digit)\n            continues_span = digit_prev | (dot_prev &amp; digit_prev2)\n        else:\n            continues_span = digit_prev\n\n        # A span starts wherever we're \"in_number\" but not continuing a previous span\n        span_start = in_number &amp; ~continues_span\n\n        # -------------------------------------------------------------------------\n        # 3) Assign each in-number token a segment id (per batch element)\n        # -------------------------------------------------------------------------\n        # seg_id is 0 for non-number tokens, otherwise 1..K within each row\n        seg_id = torch.cumsum(span_start.to(torch.int32), dim=1)\n        seg_id = seg_id * in_number.to(torch.int32)  # zero out non-number tokens\n\n        # How many segments max per row? Needed for a stable \"global segment id\"\n        segs_per_row = seg_id.max(dim=1).values  # (B,)\n        max_segs = int(segs_per_row.max().item())\n        if max_segs == 0:\n            return y, yhat, number_token_positions\n\n        # Make segment ids unique across batch:\n        # global_seg = b * (max_segs + 1) + seg_id\n        stride = max_segs + 1\n        batch_base = (torch.arange(B, device=device, dtype=torch.int64) * stride).view(\n            B, 1\n        )\n        global_seg = batch_base + seg_id.to(torch.int64)  # (B, T), 0 means \"no segment\"\n\n        # First digit of each number span (used both for segment-local digit indexing\n        # and for writing the final number-level values back).\n        number_start = span_start &amp; is_digit  # (B, T)\n\n        # -------------------------------------------------------------------------\n        # 4) Compute per-digit exponent within each segment (not across the row)\n        # -------------------------------------------------------------------------\n        # Row-wide digit cumsum (1-based on digit positions).\n        digit_cumsum = torch.cumsum(is_digit.to(torch.int32), dim=1)\n\n        # Reuse segment ids as scatter/gather indices to stay fully vectorized.\n        total_segments = B * stride  # includes one \"non-segment\" bin per row\n        flat_seg = global_seg.view(-1)\n\n        # Total number of digits in each segment (dots excluded).\n        seg_digit_count = torch.zeros((total_segments,), device=device, dtype=torch.int32)\n        seg_digit_count.scatter_add_(0, flat_seg, is_digit.to(torch.int32).view(-1))\n\n        # Row digit count before the first digit of each segment.\n        seg_digit_offset = torch.zeros(\n            (total_segments,), device=device, dtype=torch.int32\n        )\n        seg_digit_offset.scatter_(\n            0,\n            global_seg[number_start],\n            (digit_cumsum[number_start] - 1).to(torch.int32),\n        )\n\n        # Segment-local 1-based digit index, then convert to base-10 exponent.\n        digit_idx_in_seg = digit_cumsum - seg_digit_offset[global_seg]\n        exponent = (seg_digit_count[global_seg] - digit_idx_in_seg).clamp_min(0).to(\n            torch.int64\n        )\n\n        # Keep exponents within our precomputed range (or assert if you prefer strict behavior)\n        exponent = exponent.clamp_max(self.max_number_length - 1)\n\n        pow10_y = self.powers_of_10.to(device=device, dtype=y.dtype)  # (L,)\n        scale_y = pow10_y[exponent]  # (B, T)\n        if yhat.dtype == y.dtype:\n            scale_yhat = scale_y\n        else:\n            scale_yhat = self.powers_of_10.to(device=device, dtype=yhat.dtype)[\n                exponent\n            ]\n\n        # -------------------------------------------------------------------------\n        # 5) Compute digit contributions and sum per segment via scatter_add\n        # -------------------------------------------------------------------------\n        # Only digits contribute; dots/non-number contribute 0.\n        y_contrib = torch.where(is_digit, y * scale_y, torch.zeros((), device=device, dtype=y.dtype))\n        yhat_contrib = torch.where(\n            is_digit, yhat * scale_yhat, torch.zeros((), device=device, dtype=yhat.dtype)\n        )\n\n        seg_sum_y = torch.zeros((total_segments,), device=device, dtype=y.dtype)\n        seg_sum_yhat = torch.zeros((total_segments,), device=device, dtype=yhat.dtype)\n        seg_sum_y.scatter_add_(0, flat_seg, y_contrib.view(-1))\n        seg_sum_yhat.scatter_add_(0, flat_seg, yhat_contrib.view(-1))\n\n        # -------------------------------------------------------------------------\n        # 6) Write segment sums back only at the *first digit* position of each span\n        # -------------------------------------------------------------------------\n        # Important: if float_level=True, span_start could be a dot (but we want first *digit*).\n\n        y_new = y.clone()\n        yhat_new = yhat.clone()\n\n        # Everything inside a span but not the start digit becomes NaN (incl. dots, other digits)\n        in_span_not_start = in_number &amp; ~number_start\n        y_new = y_new.masked_fill(in_span_not_start, float(\"nan\"))\n        yhat_new = yhat_new.masked_fill(in_span_not_start, float(\"nan\"))\n\n        # Fill starts with summed values\n        start_seg = global_seg[number_start]  # (N,)\n        y_new[number_start] = seg_sum_y[start_seg]\n        yhat_new[number_start] = seg_sum_yhat[start_seg]\n\n        # Mask now indicates number-level positions (one per number span)\n        number_token_positions_new = number_start\n\n        return y_new, yhat_new, number_token_positions_new\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL based on the dot product between token values and their probs.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                0-D if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, _ = self._prepare_number_token_targets(labels, loss_weights, ignore_index)\n        number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n        # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or (\n            loss_weights is not None and not loss_weights.any()\n        ):\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(labels, dtype=logits.dtype)\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        yhat = self._get_dot_product(logits=logits)\n\n        y, yhat, number_token_positions = self.convert_digits_to_numbers(\n            y, yhat, number_token_positions, labels\n        )\n        if loss_weights is None:\n            loss_weights = torch.ones_like(labels, dtype=logits.dtype)\n        loss_weights = loss_weights[number_token_positions]\n\n        # NOTE: Alternative could be to apply specified loss function to normalized yhat\n        # loss = self.loss_function(torch.div(\n        #     yhat[number_token_positions],\n        #     y[number_token_positions].clamp_min(torch.finfo(y.dtype).eps),\n        # ), torch.ones_like(yhat), reduction=\"none\")\n\n        y_num = y[number_token_positions]\n        yh_num = yhat[number_token_positions]\n        # Calculate symmetric MAPE which is bounded in [0, 1]\n        loss = (yh_num - y_num).abs() / (\n            yh_num.abs() + y_num.abs() + torch.finfo(y.dtype).eps\n        )\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/#ntloss.core.NumberLevelLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, float_level: bool = False, reweigh: bool = True, max_number_length: int = 20)</code>","text":"<p>NTL constructor for the number-level NTLoss.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Any HuggingFace tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>float_level</code> <code>bool</code> <p>Whether to calculate the loss for every float or every integer in the sequence. For <code>12.34</code>, if float_level=False, two loss terms will be calculated, respectively for <code>12</code> and <code>34</code>. If float_level=True, a single <code>.</code> does not break the contiguity of the identified number. Defaults to False.</p> <code>False</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens. Using this will explode the NL-NTL in the current implementation, so reweighing for the NL-NTL needs to be refined.</p> <code>True</code> <code>max_number_length</code> <code>int</code> <p>Maximum expected length of a number in tokens. Used for precomputing power masks. Defaults to 20.</p> <code>20</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    float_level: bool = False,\n    reweigh: bool = True,\n    max_number_length: int = 20,\n):\n    \"\"\"\n    NTL constructor for the number-level NTLoss.\n\n    Args:\n        tokenizer: Any HuggingFace tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        float_level: Whether to calculate the loss for every float or every\n            integer in the sequence. For `12.34`, if float_level=False, two\n            loss terms will be calculated, respectively for `12` and `34`.\n            If float_level=True, a single `.` does not break the contiguity\n            of the identified number. Defaults to False.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n            Using this will explode the NL-NTL in the current implementation,\n            so reweighing for the NL-NTL needs to be refined.\n        max_number_length: Maximum expected length of a number in tokens.\n            Used for precomputing power masks. Defaults to 20.\n\n    \"\"\"\n    # digit_level must be set to True.\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=True,\n        reweigh=reweigh,\n        loss_function=F.l1_loss,  # unused\n    )\n    self.float_level = float_level\n    dot_result = self.tokenizer.convert_tokens_to_ids(\".\")\n    # Ensure we get an int, not a list\n    self.dot: int = dot_result if isinstance(dot_result, int) else dot_result[0]\n\n    # Precompute powers of 10 for efficiency\n    self.max_number_length = max_number_length\n    self.powers_of_10 = torch.pow(\n        10.0, torch.arange(max_number_length, dtype=torch.float32)\n    )\n</code></pre>"},{"location":"api/#ntloss.core.NumberLevelLoss.setup_max_dist","title":"<code>setup_max_dist()</code>","text":"<p>Due to the MAPE loss calculation, the max dist is limited to 1.0</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_max_dist(self):\n    \"\"\"\n    Due to the MAPE loss calculation, the max dist is limited to 1.0\n    \"\"\"\n    self.max_dist = torch.tensor(1.0)\n</code></pre>"},{"location":"api/#ntloss.core.NumberLevelLoss.convert_digits_to_numbers","title":"<code>convert_digits_to_numbers(y: FloatTensor, yhat: FloatTensor, number_token_positions: BoolTensor, labels: LongTensor)</code>","text":"<p>Vectorized conversion of digit-level number tokens to number-level values.</p> <p>Output convention: - Only the first digit of each detected number span contains the full number. - All other digits (and in float_level=True also the dot token) inside the span     are set to NaN and removed from number_token_positions. - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\") - float_level=True : a single '.' between digits is part of the span but contributes 0                     (12.34 -&gt; \"1234\" as integer-like concatenation)</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>FloatTensor</code> <p>(B, T) float, GT digit values at digit positions, NaN elsewhere</p> required <code>yhat</code> <code>FloatTensor</code> <p>(B, T) float, predicted digit values at all positions</p> required <code>number_token_positions</code> <code>BoolTensor</code> <p>(B, T) bool, True at digit positions</p> required <code>labels</code> <code>LongTensor</code> <p>(B, T) long, token ids</p> required <p>Returns:</p> Type Description <p>(y_new, yhat_new, number_token_positions_new) at number-level</p> Source code in <code>ntloss/core.py</code> <pre><code>def convert_digits_to_numbers(\n    self,\n    y: FloatTensor,\n    yhat: FloatTensor,\n    number_token_positions: BoolTensor,\n    labels: LongTensor,\n):\n    \"\"\"\n    Vectorized conversion of digit-level number tokens to number-level values.\n\n    Output convention:\n    - Only the *first digit* of each detected number span contains the full number.\n    - All other digits (and in float_level=True also the dot token) inside the span\n        are set to NaN and removed from number_token_positions.\n    - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\")\n    - float_level=True : a single '.' between digits is part of the span but contributes 0\n                        (12.34 -&gt; \"1234\" as integer-like concatenation)\n\n    Args:\n        y: (B, T) float, GT digit values at digit positions, NaN elsewhere\n        yhat: (B, T) float, predicted digit values at all positions\n        number_token_positions: (B, T) bool, True at digit positions\n        labels: (B, T) long, token ids\n\n    Returns:\n        (y_new, yhat_new, number_token_positions_new) at number-level\n    \"\"\"\n    B, T = y.shape\n    device = y.device\n    is_digit = number_token_positions  # (B, T)\n    if not is_digit.any():\n        return y, yhat, number_token_positions\n\n    # -------------------------------------------------------------------------\n    # 1) Decide which tokens are considered \"inside a number span\"\n    # -------------------------------------------------------------------------\n    # Base: digits are always in spans\n    in_number: BoolTensor = is_digit\n\n    if self.float_level:\n        is_dot = labels.eq(self.dot)  # (B, T)\n\n        # dot is part of a number span only if it is *between* digits: d . d\n        digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_prev[:, 1:] = is_digit[:, :-1]\n\n        digit_next = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_next[:, :-1] = is_digit[:, 1:]\n\n        dot_between_digits = is_dot &amp; digit_prev &amp; digit_next\n\n        # In float mode, those dots count as \"in number\" (but contribute 0 later)\n        in_number = cast(BoolTensor, in_number | dot_between_digits)\n    else:\n        dot_between_digits = torch.zeros((B, T), dtype=torch.bool, device=device)\n\n    # -------------------------------------------------------------------------\n    # 2) Build a \"continuation\" mask: does position t continue a span from t-1?\n    # -------------------------------------------------------------------------\n    # If previous token is a digit =&gt; continuation for digits (and for dot-between-digits in float mode)\n    digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n    digit_prev[:, 1:] = is_digit[:, :-1]\n\n    if self.float_level:\n        is_dot = labels.eq(self.dot)\n\n        dot_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        dot_prev[:, 1:] = is_dot[:, :-1]\n\n        digit_prev2 = torch.zeros((B, T), dtype=torch.bool, device=device)\n        if T &gt; 2:\n            digit_prev2[:, 2:] = is_digit[:, :-2]\n\n        # Continue if:\n        #  - previous is digit, OR\n        #  - previous is dot and the token before that is digit (digit . digit)\n        continues_span = digit_prev | (dot_prev &amp; digit_prev2)\n    else:\n        continues_span = digit_prev\n\n    # A span starts wherever we're \"in_number\" but not continuing a previous span\n    span_start = in_number &amp; ~continues_span\n\n    # -------------------------------------------------------------------------\n    # 3) Assign each in-number token a segment id (per batch element)\n    # -------------------------------------------------------------------------\n    # seg_id is 0 for non-number tokens, otherwise 1..K within each row\n    seg_id = torch.cumsum(span_start.to(torch.int32), dim=1)\n    seg_id = seg_id * in_number.to(torch.int32)  # zero out non-number tokens\n\n    # How many segments max per row? Needed for a stable \"global segment id\"\n    segs_per_row = seg_id.max(dim=1).values  # (B,)\n    max_segs = int(segs_per_row.max().item())\n    if max_segs == 0:\n        return y, yhat, number_token_positions\n\n    # Make segment ids unique across batch:\n    # global_seg = b * (max_segs + 1) + seg_id\n    stride = max_segs + 1\n    batch_base = (torch.arange(B, device=device, dtype=torch.int64) * stride).view(\n        B, 1\n    )\n    global_seg = batch_base + seg_id.to(torch.int64)  # (B, T), 0 means \"no segment\"\n\n    # First digit of each number span (used both for segment-local digit indexing\n    # and for writing the final number-level values back).\n    number_start = span_start &amp; is_digit  # (B, T)\n\n    # -------------------------------------------------------------------------\n    # 4) Compute per-digit exponent within each segment (not across the row)\n    # -------------------------------------------------------------------------\n    # Row-wide digit cumsum (1-based on digit positions).\n    digit_cumsum = torch.cumsum(is_digit.to(torch.int32), dim=1)\n\n    # Reuse segment ids as scatter/gather indices to stay fully vectorized.\n    total_segments = B * stride  # includes one \"non-segment\" bin per row\n    flat_seg = global_seg.view(-1)\n\n    # Total number of digits in each segment (dots excluded).\n    seg_digit_count = torch.zeros((total_segments,), device=device, dtype=torch.int32)\n    seg_digit_count.scatter_add_(0, flat_seg, is_digit.to(torch.int32).view(-1))\n\n    # Row digit count before the first digit of each segment.\n    seg_digit_offset = torch.zeros(\n        (total_segments,), device=device, dtype=torch.int32\n    )\n    seg_digit_offset.scatter_(\n        0,\n        global_seg[number_start],\n        (digit_cumsum[number_start] - 1).to(torch.int32),\n    )\n\n    # Segment-local 1-based digit index, then convert to base-10 exponent.\n    digit_idx_in_seg = digit_cumsum - seg_digit_offset[global_seg]\n    exponent = (seg_digit_count[global_seg] - digit_idx_in_seg).clamp_min(0).to(\n        torch.int64\n    )\n\n    # Keep exponents within our precomputed range (or assert if you prefer strict behavior)\n    exponent = exponent.clamp_max(self.max_number_length - 1)\n\n    pow10_y = self.powers_of_10.to(device=device, dtype=y.dtype)  # (L,)\n    scale_y = pow10_y[exponent]  # (B, T)\n    if yhat.dtype == y.dtype:\n        scale_yhat = scale_y\n    else:\n        scale_yhat = self.powers_of_10.to(device=device, dtype=yhat.dtype)[\n            exponent\n        ]\n\n    # -------------------------------------------------------------------------\n    # 5) Compute digit contributions and sum per segment via scatter_add\n    # -------------------------------------------------------------------------\n    # Only digits contribute; dots/non-number contribute 0.\n    y_contrib = torch.where(is_digit, y * scale_y, torch.zeros((), device=device, dtype=y.dtype))\n    yhat_contrib = torch.where(\n        is_digit, yhat * scale_yhat, torch.zeros((), device=device, dtype=yhat.dtype)\n    )\n\n    seg_sum_y = torch.zeros((total_segments,), device=device, dtype=y.dtype)\n    seg_sum_yhat = torch.zeros((total_segments,), device=device, dtype=yhat.dtype)\n    seg_sum_y.scatter_add_(0, flat_seg, y_contrib.view(-1))\n    seg_sum_yhat.scatter_add_(0, flat_seg, yhat_contrib.view(-1))\n\n    # -------------------------------------------------------------------------\n    # 6) Write segment sums back only at the *first digit* position of each span\n    # -------------------------------------------------------------------------\n    # Important: if float_level=True, span_start could be a dot (but we want first *digit*).\n\n    y_new = y.clone()\n    yhat_new = yhat.clone()\n\n    # Everything inside a span but not the start digit becomes NaN (incl. dots, other digits)\n    in_span_not_start = in_number &amp; ~number_start\n    y_new = y_new.masked_fill(in_span_not_start, float(\"nan\"))\n    yhat_new = yhat_new.masked_fill(in_span_not_start, float(\"nan\"))\n\n    # Fill starts with summed values\n    start_seg = global_seg[number_start]  # (N,)\n    y_new[number_start] = seg_sum_y[start_seg]\n    yhat_new[number_start] = seg_sum_yhat[start_seg]\n\n    # Mask now indicates number-level positions (one per number span)\n    number_token_positions_new = number_start\n\n    return y_new, yhat_new, number_token_positions_new\n</code></pre>"},{"location":"api/#ntloss.core.NumberLevelLoss.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL based on the dot product between token values and their probs.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>2D Optional tensor of BS x T with token-wise loss weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor 0-D if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL based on the dot product between token values and their probs.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            0-D if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, _ = self._prepare_number_token_targets(labels, loss_weights, ignore_index)\n    number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n    # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or (\n        loss_weights is not None and not loss_weights.any()\n    ):\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(labels, dtype=logits.dtype)\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    yhat = self._get_dot_product(logits=logits)\n\n    y, yhat, number_token_positions = self.convert_digits_to_numbers(\n        y, yhat, number_token_positions, labels\n    )\n    if loss_weights is None:\n        loss_weights = torch.ones_like(labels, dtype=logits.dtype)\n    loss_weights = loss_weights[number_token_positions]\n\n    # NOTE: Alternative could be to apply specified loss function to normalized yhat\n    # loss = self.loss_function(torch.div(\n    #     yhat[number_token_positions],\n    #     y[number_token_positions].clamp_min(torch.finfo(y.dtype).eps),\n    # ), torch.ones_like(yhat), reduction=\"none\")\n\n    y_num = y[number_token_positions]\n    yh_num = yhat[number_token_positions]\n    # Calculate symmetric MAPE which is bounded in [0, 1]\n    loss = (yh_num - y_num).abs() / (\n        yh_num.abs() + y_num.abs() + torch.finfo(y.dtype).eps\n    )\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/#ntlossutils","title":"ntloss.utils","text":""},{"location":"api/#ntloss.utils","title":"<code>ntloss.utils</code>","text":""},{"location":"api/#ntloss.utils.is_number","title":"<code>is_number(something: Any, finite: bool = True) -&gt; bool</code>","text":"<p>Check whether something is convertible to a float</p> <p>Parameters:</p> Name Type Description Default <code>something</code> <code>Any</code> <p>something to test for float casting.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not it's a number</p> Source code in <code>ntloss/utils.py</code> <pre><code>def is_number(something: Any, finite: bool = True) -&gt; bool:\n    \"\"\"Check whether something is convertible to a float\n\n    Args:\n        something: something to test for float casting.\n\n    Returns:\n        Whether or not it's a number\n    \"\"\"\n    try:\n        f = float(something)\n        if finite and not math.isfinite(f):\n            return False\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/core/","title":"ntloss.core","text":""},{"location":"api/core/#ntloss.core","title":"<code>ntloss.core</code>","text":""},{"location":"api/core/#ntloss.core.AbstractNTLoss","title":"<code>AbstractNTLoss</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ntloss/core.py</code> <pre><code>class AbstractNTLoss(ABC):\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n    ):\n        \"\"\"\n        NTL constructor.\n\n        Args:\n            tokenizer: Standard HF tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n\n        \"\"\"\n        super().__init__()\n        self.tokenizer = tokenizer\n        self.vocab_size = vocab_size if vocab_size is not None else len(self.tokenizer)\n        self._vocab_size_validated = False\n        self.digit_level = digit_level\n        self.reweigh = reweigh\n\n        self.setup_number_tokens()\n\n        self.max_dist = torch.tensor(0.0)\n\n    def setup_number_tokens(self):\n        \"\"\"Setting up attributes needed by NT loss\"\"\"\n\n        # Add digits to vocab if not there yet.\n        vocab_size = len(self.tokenizer)\n        if self.digit_level:\n            new_tokens = self.tokenizer.add_tokens(list(map(str, range(10))))\n        if vocab_size &lt; len(self.tokenizer) and new_tokens &gt; 0:\n            logger.warning(f\"Added {new_tokens} new tokens for number token loss\")\n        vocab = self.tokenizer.get_vocab()\n        self.number_values: FloatTensor = torch.full((self.vocab_size,), float(\"nan\"))\n\n        # Try to convert each token to a float after stripping the space prefix\n        for token, id in vocab.items():\n            if is_number(token, finite=True):\n                if self.digit_level:\n                    # NOTE: This check ensures number token value only occurs for digits, not for multi-digit numbers (123)\n                    # This stabilizes training with NTL. Can be altered though, see paper experiments.\n                    # Excludes tokens that are numbers in other languages like \u1098 and tokens with space pre-/postfix like ` 2`.\n                    if token.isascii() and -1 &lt;= float(token) &lt;= 9 and len(token) == 1:\n                        self.number_values[id] = float(token)\n                else:\n                    self.number_values[id] = float(token)\n\n        self.is_number_token = ~torch.isnan(self.number_values)\n        if self.is_number_token.sum() == len(self.is_number_token):\n            raise ValueError(\n                \"At least one token needs to be not a number, otherwise `ignore_index` cannot be set up safely\"\n            )\n        self.nan_id = torch.where(~self.is_number_token)[0][0].item()\n        self.number_values_dense = self.number_values[self.is_number_token]\n\n        if self.digit_level and (num_nts := len(self.number_values_dense)) != 10:\n            logger.error(\n                f\"You requested digit-level but {num_nts} number tokens were identified: {self.number_values_dense}\"\n            )\n        self.number_token_ids = torch.nonzero(\n            self.is_number_token, as_tuple=False\n        ).squeeze(1)\n        self._nt_ids_cache: dict[torch.device, torch.Tensor] = {}\n\n    @abstractmethod\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n    ) -&gt; Tensor: ...\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Alias to self.forward\"\"\"\n        return self.forward(*args, **kwargs)\n\n    def reweigh_fn(\n        self,\n        logits: Tensor,\n        loss: Tensor,\n        number_token_positions: Tensor,\n    ) -&gt; Tensor:\n        \"\"\"\n        Scale the NT loss element-wise using the logit weight on number tokens.\n        NOTE: This reweighing ensures that if ground truth is a number token\n            but most probability mass is on text tokens, the loss will be *higher*\n            than the worst possible number token. Mostly to accelerate early training.\n        NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            loss: 1D Tensor over all number tokens in batch.\n            number_token_positions: 2D Tensor of shape BS x T indicating for which tokens\n                the NT loss was computed.\n\n        Returns:\n            A 1D Tensor over all number tokens in batch with the scaled NT losses.\n        \"\"\"\n\n        nt_logits = logits[number_token_positions]\n        nt_ids = self._nt_ids_cache.get(nt_logits.device)\n        if nt_ids is None:\n            nt_ids = self.number_token_ids.to(nt_logits.device)\n            self._nt_ids_cache[nt_logits.device] = nt_ids\n\n        # Softmax and mass only for relevant positions\n        nt_probs = torch.softmax(nt_logits, dim=-1)  # (K, V)\n        nt_mass = nt_probs.index_select(dim=-1, index=nt_ids).sum(dim=-1)\n\n        # Apply regularization (in place is faster)\n        loss.mul_(nt_mass)\n        # NOTE: We could consider reweighing here with the max for that label token\n        # rather than the global max\n        loss.add_(\n            1.01\n            * self.max_dist.to(dtype=loss.dtype, device=loss.device)\n            * (1 - nt_mass)\n        )\n        return loss\n\n    def _validate_inputs(\n        self,\n        logits: FloatTensor,\n        labels: Optional[LongTensor],\n        loss_weights: Optional[Tensor],\n    ):\n        \"\"\"Private method to perform size and type checks.\"\"\"\n        if (td := len(logits.shape)) != 3 or logits.numel() == 0:\n            raise ValueError(\n                f\"Logits have to be non-empty 3D Tensor, not {td}D with {logits.numel()} elements\"\n            )\n        if not torch.is_floating_point(logits):\n            raise TypeError(\"Logits have to be FloatTensor.\")\n        if labels is None:\n            return\n        if not labels.dtype == torch.long:\n            raise TypeError(f\"Labels have to be LongTensor, not {type(labels)}\")\n        if (b := labels.shape) != (a := logits.shape[:-1]):\n            raise ValueError(\n                f\"Logit and label sizes of first 2 dims have to match: {a} vs {b}\"\n            )\n\n        if (td := len(labels.shape)) != 2 or labels.numel() == 0:\n            raise ValueError(\n                f\"Labels have to be non-empty 2D Tensor, not {td}D with {labels.numel()} elements\"\n            )\n        if loss_weights is not None:\n            if loss_weights.shape != labels.shape:\n                raise ValueError(\n                    \"Loss mask has to be 2D Tensor of same shape as labels.\"\n                )\n            if torch.any(loss_weights &lt; 0):\n                raise ValueError(\"loss_mask must be \u2265 0.\")\n\n        if not self._vocab_size_validated:\n            logits_vocab_size = logits.shape[-1]\n            if logits_vocab_size != self.vocab_size:\n                raise ValueError(\n                    f\"The current `vocab_size` ({self.vocab_size}) does not match the model's vocab size\"\n                    f\"logit dimension ({logits_vocab_size}). Please check the value.\"\n                )\n            self._vocab_size_validated = True\n\n    def _prepare_number_token_targets(\n        self, labels: LongTensor, loss_weights: Optional[Tensor], ignore_index: int\n    ) -&gt; Tuple[FloatTensor, Tensor]:\n        \"\"\"\n        Prepare number-token targets and masks.\n\n        Args:\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: Optional 2D Tensor of shape BS x T with loss weight for each token.\n            ignore_index: Label ID to ignore. Defaults to -100.\n\n        Returns:\n            y: 2D Float Tensor of shape BS x T with target numeric values (NaN for non-number tokens).\n            loss_weight: 1D Tensor with a potentially individual loss weight for each number token position.\n        \"\"\"\n        labels = cast(\n            LongTensor, labels.masked_fill(labels == ignore_index, self.nan_id)\n        )\n        # Create a mask to filter out non-digit tokens\n        y = self.number_values.to(device=labels.device)[labels]\n        number_token_positions = ~torch.isnan(y)\n        loss_weights = (\n            loss_weights[number_token_positions]\n            if loss_weights is not None\n            else torch.ones_like(labels, device=labels.device)[number_token_positions]\n        )\n        return cast(FloatTensor, y), loss_weights\n\n    @staticmethod\n    def _apply_reduction(\n        loss: Tensor,\n        reduction: str,\n        loss_weights: Tensor,\n        number_token_positions: Tensor,\n        logits: Tensor,\n    ) -&gt; Tensor:\n        \"\"\"\n        Applies the specified reduction type to the calculated loss.\n\n        This method handles 3 types of reduction: \"mean\", \"sum\", and \"none\".\n        For \"mean\" and \"sum\", it applies weighting using `loss_weights`.\n        For \"none\", it reshapes the loss back to the original batch and sequence\n        dimensions.\n\n        Args:\n            loss: 1D Tensor containing the loss for each number token in the batch.\n            reduction: The reduction method (\"mean\", \"sum\", or \"none\").\n            loss_weights: 1D Tensor with a loss weight for each number token.\n            number_token_positions: 2D boolean tensor of shape BS x T indicating\n                the positions of number tokens.\n            logits: 3D Tensor of shape BS x T x V, used to get the original shape\n                for the \"none\" reduction.\n\n        Returns:\n            A Tensor representing the reduced loss:\n                - 0D tensor if `reduction` is \"mean\" or \"sum\".\n                - 2D Tensor of shape BS x T if `reduction` is \"none\".\n        \"\"\"\n        loss_weights = loss_weights.to(device=loss.device, dtype=loss.dtype)\n        if reduction == \"mean\":\n            # Mean pooling (weighted by loss mask)\n            loss = torch.dot(\n                loss.flatten(), loss_weights.flatten()\n            ) / loss_weights.sum().clamp_min(torch.finfo(loss.dtype).eps)\n        elif reduction == \"sum\":\n            loss = torch.dot(loss.flatten(), loss_weights.flatten())\n        elif reduction == \"none\":\n            # Cast loss for number tokens back to Tensor of size BS x T\n            loss_ = torch.zeros(number_token_positions.numel()).to(loss.device)\n            loss_[number_token_positions.view(-1)] = loss * loss_weights\n            bs, seq_len, _ = logits.size()\n            loss = loss_.view(bs, seq_len)\n\n            assert torch.sum(loss[~number_token_positions]) == 0, (\n                \"NumberTokenLoss computed for non-digit tokens!\"\n            )\n\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.AbstractNTLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True)</code>","text":"<p>NTL constructor.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Standard HF tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n):\n    \"\"\"\n    NTL constructor.\n\n    Args:\n        tokenizer: Standard HF tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n\n    \"\"\"\n    super().__init__()\n    self.tokenizer = tokenizer\n    self.vocab_size = vocab_size if vocab_size is not None else len(self.tokenizer)\n    self._vocab_size_validated = False\n    self.digit_level = digit_level\n    self.reweigh = reweigh\n\n    self.setup_number_tokens()\n\n    self.max_dist = torch.tensor(0.0)\n</code></pre>"},{"location":"api/core/#ntloss.core.AbstractNTLoss.setup_number_tokens","title":"<code>setup_number_tokens()</code>","text":"<p>Setting up attributes needed by NT loss</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_number_tokens(self):\n    \"\"\"Setting up attributes needed by NT loss\"\"\"\n\n    # Add digits to vocab if not there yet.\n    vocab_size = len(self.tokenizer)\n    if self.digit_level:\n        new_tokens = self.tokenizer.add_tokens(list(map(str, range(10))))\n    if vocab_size &lt; len(self.tokenizer) and new_tokens &gt; 0:\n        logger.warning(f\"Added {new_tokens} new tokens for number token loss\")\n    vocab = self.tokenizer.get_vocab()\n    self.number_values: FloatTensor = torch.full((self.vocab_size,), float(\"nan\"))\n\n    # Try to convert each token to a float after stripping the space prefix\n    for token, id in vocab.items():\n        if is_number(token, finite=True):\n            if self.digit_level:\n                # NOTE: This check ensures number token value only occurs for digits, not for multi-digit numbers (123)\n                # This stabilizes training with NTL. Can be altered though, see paper experiments.\n                # Excludes tokens that are numbers in other languages like \u1098 and tokens with space pre-/postfix like ` 2`.\n                if token.isascii() and -1 &lt;= float(token) &lt;= 9 and len(token) == 1:\n                    self.number_values[id] = float(token)\n            else:\n                self.number_values[id] = float(token)\n\n    self.is_number_token = ~torch.isnan(self.number_values)\n    if self.is_number_token.sum() == len(self.is_number_token):\n        raise ValueError(\n            \"At least one token needs to be not a number, otherwise `ignore_index` cannot be set up safely\"\n        )\n    self.nan_id = torch.where(~self.is_number_token)[0][0].item()\n    self.number_values_dense = self.number_values[self.is_number_token]\n\n    if self.digit_level and (num_nts := len(self.number_values_dense)) != 10:\n        logger.error(\n            f\"You requested digit-level but {num_nts} number tokens were identified: {self.number_values_dense}\"\n        )\n    self.number_token_ids = torch.nonzero(\n        self.is_number_token, as_tuple=False\n    ).squeeze(1)\n    self._nt_ids_cache: dict[torch.device, torch.Tensor] = {}\n</code></pre>"},{"location":"api/core/#ntloss.core.AbstractNTLoss.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Alias to self.forward</p> Source code in <code>ntloss/core.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    \"\"\"Alias to self.forward\"\"\"\n    return self.forward(*args, **kwargs)\n</code></pre>"},{"location":"api/core/#ntloss.core.AbstractNTLoss.reweigh_fn","title":"<code>reweigh_fn(logits: Tensor, loss: Tensor, number_token_positions: Tensor) -&gt; Tensor</code>","text":"<p>Scale the NT loss element-wise using the logit weight on number tokens. NOTE: This reweighing ensures that if ground truth is a number token     but most probability mass is on text tokens, the loss will be higher     than the worst possible number token. Mostly to accelerate early training. NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>Tensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>loss</code> <code>Tensor</code> <p>1D Tensor over all number tokens in batch.</p> required <code>number_token_positions</code> <code>Tensor</code> <p>2D Tensor of shape BS x T indicating for which tokens the NT loss was computed.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A 1D Tensor over all number tokens in batch with the scaled NT losses.</p> Source code in <code>ntloss/core.py</code> <pre><code>def reweigh_fn(\n    self,\n    logits: Tensor,\n    loss: Tensor,\n    number_token_positions: Tensor,\n) -&gt; Tensor:\n    \"\"\"\n    Scale the NT loss element-wise using the logit weight on number tokens.\n    NOTE: This reweighing ensures that if ground truth is a number token\n        but most probability mass is on text tokens, the loss will be *higher*\n        than the worst possible number token. Mostly to accelerate early training.\n    NOTE: Since NT mass is only calculated at loss positions, the overhead is tiny.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        loss: 1D Tensor over all number tokens in batch.\n        number_token_positions: 2D Tensor of shape BS x T indicating for which tokens\n            the NT loss was computed.\n\n    Returns:\n        A 1D Tensor over all number tokens in batch with the scaled NT losses.\n    \"\"\"\n\n    nt_logits = logits[number_token_positions]\n    nt_ids = self._nt_ids_cache.get(nt_logits.device)\n    if nt_ids is None:\n        nt_ids = self.number_token_ids.to(nt_logits.device)\n        self._nt_ids_cache[nt_logits.device] = nt_ids\n\n    # Softmax and mass only for relevant positions\n    nt_probs = torch.softmax(nt_logits, dim=-1)  # (K, V)\n    nt_mass = nt_probs.index_select(dim=-1, index=nt_ids).sum(dim=-1)\n\n    # Apply regularization (in place is faster)\n    loss.mul_(nt_mass)\n    # NOTE: We could consider reweighing here with the max for that label token\n    # rather than the global max\n    loss.add_(\n        1.01\n        * self.max_dist.to(dtype=loss.dtype, device=loss.device)\n        * (1 - nt_mass)\n    )\n    return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLossDotProduct","title":"<code>NTLossDotProduct</code>","text":"<p>               Bases: <code>AbstractNTLoss</code></p> <p>Class for NT losses that produce a token-wise numerical output.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NTLossDotProduct(AbstractNTLoss):\n    \"\"\"Class for NT losses that produce a token-wise numerical output.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n        loss_function: Callable = F.mse_loss,\n    ):\n        \"\"\"\n        Referred to as NTL-L_p in the paper.\n\n        Args:\n            tokenizer: NTLTokenizer with necessary attributes like is_number_token etc.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n            loss_function: Function to apply on the delta between the ground truth number\n                and the obtained dot product (nt-probs * token-values). Defaults to\n                MSE, but MAE, Huber etc are also compatible.\n        \"\"\"\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=digit_level,\n            reweigh=reweigh,\n        )\n        self.loss_function = loss_function\n        self.setup_max_dist()\n\n    def setup_max_dist(self):\n        \"\"\"\n        Set up the maximum distance between the number tokens based on the selected loss function.\n        \"\"\"\n\n        # Extract the number token values and get the minimum and maximum\n        vals = self.number_values_dense.unsqueeze(0)\n        max_val = vals.max()\n        min_val = vals.min()\n\n        # Compute the largest value the loss function used in NT loss computation can get\n        # Make sure to account for possibility of asymmetrical loss function\n        self.max_dist = torch.maximum(\n            torch.abs(self.loss_function(min_val, max_val)),\n            torch.abs(self.loss_function(max_val, min_val)),\n        )\n\n    def predict_numbers(self, logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]:\n        \"\"\"\n        Calculates token-level numerical prediction.\n        NOTE: This calculates numerical predictions for *all* tokens, not just where\n        label is a number token.\n\n        Args:\n            logits: 3D FloatTensor of shape BS x T x V.\n\n        Returns:\n            yhat: 2D FloatTensor BS x T containing numerical predictions.\n            nt_mass: 2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.\n        \"\"\"\n        self._validate_inputs(logits, labels=None, loss_weights=None)\n\n        # Calculate the token-level predictions\n        yhat = self._get_dot_product(logits=logits)\n\n        probs_all = F.softmax(logits, dim=-1)\n        probs_nt = probs_all[:, :, self.is_number_token]\n        nt_mass = probs_nt.sum(dim=-1)\n        return yhat, cast(FloatTensor, nt_mass)\n\n    def _get_dot_product(\n        self, logits: FloatTensor, number_token_positions: Optional[BoolTensor] = None\n    ) -&gt; FloatTensor:\n        \"\"\"\n        Applies dot product of number token values and their predicted probabilites.\n\n        Args:\n            logits: 3D FloatTensor of shape BS x T x V.\n            number_token_positions: Optional 2D BoolTensor (BS x T) containing locations\n                of number tokens.\n\n        Returns:\n            If `number_token_positions` is None, 2D FloatTensor of shape BS x T.\n            Otherwise, 1D FloatTensor containing the predictions for the number tokens.\n        \"\"\"\n        # apply softmax solely over the number token indices\n        nt_logits = logits[:, :, self.is_number_token]\n        softmax_probs = F.softmax(nt_logits, dim=-1)\n        values = self.number_values_dense.to(device=logits.device, dtype=logits.dtype)\n\n        # compute the weighted average of number tokens\n        if number_token_positions is None:\n            # Calculate for all tokens\n            yhat = torch.sum(softmax_probs * values, dim=-1)\n        else:\n            # Calculate selectively where labels are number tokens\n            yhat = torch.sum(softmax_probs[number_token_positions] * values, dim=-1)\n        return cast(FloatTensor, yhat)\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL based on the dot product between token values and their probs.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                OD if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, loss_weights = self._prepare_number_token_targets(\n            labels, loss_weights, ignore_index\n        )\n        loss_weights = loss_weights.to(logits.dtype)\n        number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n        # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or not loss_weights.any():\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(\n                    labels, dtype=logits.dtype, device=labels.device\n                )\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        yhat = self._get_dot_product(\n            logits=logits, number_token_positions=number_token_positions\n        )\n\n        # Apply specified loss function to y and yhat\n        loss = self.loss_function(yhat, y[number_token_positions], reduction=\"none\")\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLossDotProduct.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True, loss_function: Callable = F.mse_loss)</code>","text":"<p>Referred to as NTL-L_p in the paper.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>NTLTokenizer with necessary attributes like is_number_token etc.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> <code>loss_function</code> <code>Callable</code> <p>Function to apply on the delta between the ground truth number and the obtained dot product (nt-probs * token-values). Defaults to MSE, but MAE, Huber etc are also compatible.</p> <code>mse_loss</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n    loss_function: Callable = F.mse_loss,\n):\n    \"\"\"\n    Referred to as NTL-L_p in the paper.\n\n    Args:\n        tokenizer: NTLTokenizer with necessary attributes like is_number_token etc.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n        loss_function: Function to apply on the delta between the ground truth number\n            and the obtained dot product (nt-probs * token-values). Defaults to\n            MSE, but MAE, Huber etc are also compatible.\n    \"\"\"\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=digit_level,\n        reweigh=reweigh,\n    )\n    self.loss_function = loss_function\n    self.setup_max_dist()\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLossDotProduct.setup_max_dist","title":"<code>setup_max_dist()</code>","text":"<p>Set up the maximum distance between the number tokens based on the selected loss function.</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_max_dist(self):\n    \"\"\"\n    Set up the maximum distance between the number tokens based on the selected loss function.\n    \"\"\"\n\n    # Extract the number token values and get the minimum and maximum\n    vals = self.number_values_dense.unsqueeze(0)\n    max_val = vals.max()\n    min_val = vals.min()\n\n    # Compute the largest value the loss function used in NT loss computation can get\n    # Make sure to account for possibility of asymmetrical loss function\n    self.max_dist = torch.maximum(\n        torch.abs(self.loss_function(min_val, max_val)),\n        torch.abs(self.loss_function(max_val, min_val)),\n    )\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLossDotProduct.predict_numbers","title":"<code>predict_numbers(logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]</code>","text":"<p>Calculates token-level numerical prediction. NOTE: This calculates numerical predictions for all tokens, not just where label is a number token.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D FloatTensor of shape BS x T x V.</p> required <p>Returns:</p> Name Type Description <code>yhat</code> <code>FloatTensor</code> <p>2D FloatTensor BS x T containing numerical predictions.</p> <code>nt_mass</code> <code>FloatTensor</code> <p>2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.</p> Source code in <code>ntloss/core.py</code> <pre><code>def predict_numbers(self, logits: FloatTensor) -&gt; Tuple[FloatTensor, FloatTensor]:\n    \"\"\"\n    Calculates token-level numerical prediction.\n    NOTE: This calculates numerical predictions for *all* tokens, not just where\n    label is a number token.\n\n    Args:\n        logits: 3D FloatTensor of shape BS x T x V.\n\n    Returns:\n        yhat: 2D FloatTensor BS x T containing numerical predictions.\n        nt_mass: 2D FloatTensor BS x T with the cumulated mass assigned to all number tokens.\n    \"\"\"\n    self._validate_inputs(logits, labels=None, loss_weights=None)\n\n    # Calculate the token-level predictions\n    yhat = self._get_dot_product(logits=logits)\n\n    probs_all = F.softmax(logits, dim=-1)\n    probs_nt = probs_all[:, :, self.is_number_token]\n    nt_mass = probs_nt.sum(dim=-1)\n    return yhat, cast(FloatTensor, nt_mass)\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLossDotProduct.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL based on the dot product between token values and their probs.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>2D Optional tensor of BS x T with token-wise loss weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor OD if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL based on the dot product between token values and their probs.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            OD if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, loss_weights = self._prepare_number_token_targets(\n        labels, loss_weights, ignore_index\n    )\n    loss_weights = loss_weights.to(logits.dtype)\n    number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n    # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or not loss_weights.any():\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(\n                labels, dtype=logits.dtype, device=labels.device\n            )\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    yhat = self._get_dot_product(\n        logits=logits, number_token_positions=number_token_positions\n    )\n\n    # Apply specified loss function to y and yhat\n    loss = self.loss_function(yhat, y[number_token_positions], reduction=\"none\")\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLoss","title":"<code>NTLoss</code>","text":"<p>               Bases: <code>AbstractNTLoss</code></p> <p>Class for Wasserstein-based NTLoss. This is the default in the ICML paper.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NTLoss(AbstractNTLoss):\n    \"\"\"Class for Wasserstein-based NTLoss. This is the default in the ICML paper.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        digit_level: bool = True,\n        reweigh: bool = True,\n        squash_factor: Optional[float] = None,\n    ):\n        \"\"\"\n        NTL constructor for the Wasserstein-based NTLoss.\n\n        Args:\n            tokenizer: Any HuggingFace tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            digit_level: Whether to ensure only digits are considered number tokens,\n                stabilizing training with NTL. Defaults to True. Used for most\n                experiments in the ICML paper.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n            squash_factor: The optional squashing factor for the NTL. If provided,\n                this number denotes the factor by which predicting the largest number\n                token is worse than predicting the closest incorrect number token.\n                E.g., with digit-level tokenization this factor is 9. Setting this\n                to 1 will recover cross entropy. This argument is intended to handle\n                irregular vocabs with large numerical token values.\n        \"\"\"\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=digit_level,\n            reweigh=reweigh,\n        )\n\n        self.squash_factor = squash_factor\n        self.setup_distance_lookup(squash_factor)\n\n    def setup_distance_lookup(\n        self,\n        squash_factor: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"\n        Set up a lookup table for the distances between the number tokens.\n        Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token.\n        If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9.\n        NOTE: With a squashing factor of 1, this basically collapses to cross entropy.\n\n        Args:\n            squash_factor: The optional squashing factor used.\n        \"\"\"\n\n        # Get token ids for number tokens\n        num_ids = torch.nonzero(self.is_number_token, as_tuple=True)[0]\n        # Create mapping from number token ids to their index in order of appearance in vocab:\n        # e.g. token \"3\" -&gt; id 519 -&gt; dist_idx 1, then abs dist to 3 for other NT values will be found in row/column 1\n        vocab_to_dist_idx = torch.full((self.vocab_size,), -1, dtype=torch.long)\n        # Use arange to ensure order of appearance\n        vocab_to_dist_idx[num_ids] = torch.arange(num_ids.size(0), dtype=torch.long)\n\n        # Build NxN abs-diff matrix\n        vals = self.number_values_dense.unsqueeze(0)  # (1 x N)\n        diff = torch.abs(vals - vals.t())  # (N x N)\n\n        if isinstance(squash_factor, Number):\n            assert squash_factor &gt; 1, (\n                f\"The squash factor can't be equal to or smaller than 1, please use a different squashing factor than {squash_factor}\"\n            )\n\n            # Mask out zeros to find the smallest nonzero diff\n            inf = torch.finfo(diff.dtype).max\n            diff_nonzero = diff.masked_fill(diff == 0, inf)\n            global_min_nz = diff_nonzero.min()\n            # Find largest diff\n            global_max = diff.max()\n\n            # Compute scaling factor based on indicated squash factor\n            scale = (squash_factor - 1) / (global_max - global_min_nz)\n            # Scale the absolute differences using scaling factor\n            lookup = 1 + (diff - global_min_nz) * scale\n            lookup[diff == 0] = 0.0\n\n        else:\n            lookup = diff\n\n        self.vocab_to_dist_idx = vocab_to_dist_idx\n        self.dist_lookup = lookup\n        self.max_dist = lookup.max()\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: Optional 2D tensor of BS x T with token-specific weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                OD if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, loss_weights = self._prepare_number_token_targets(\n            labels, loss_weights, ignore_index\n        )\n        loss_weights = loss_weights.to(logits.dtype)\n        number_token_positions = ~torch.isnan(y)\n\n        # If no digit tokens in batch, or total of the relevant loss_weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or not loss_weights.any():\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(\n                    labels, dtype=logits.dtype, device=labels.device\n                )\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        # apply softmax and get number labels\n        nt_logits = logits[:, :, self.is_number_token]\n        softmax_probs = F.softmax(nt_logits, dim=-1)\n\n        # get distance between the true numbers and all possible number values from lookup table\n        abs_diff = self.dist_lookup.to(dtype=logits.dtype, device=logits.device)[\n            self.vocab_to_dist_idx.to(device=labels.device)[\n                labels[number_token_positions]\n            ]\n        ]\n\n        # loss is the absolute difference weighted by the softmax probs\n        loss = (abs_diff * softmax_probs[number_token_positions]).sum(dim=-1)\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, digit_level: bool = True, reweigh: bool = True, squash_factor: Optional[float] = None)</code>","text":"<p>NTL constructor for the Wasserstein-based NTLoss.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Any HuggingFace tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>digit_level</code> <code>bool</code> <p>Whether to ensure only digits are considered number tokens, stabilizing training with NTL. Defaults to True. Used for most experiments in the ICML paper.</p> <code>True</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens.</p> <code>True</code> <code>squash_factor</code> <code>Optional[float]</code> <p>The optional squashing factor for the NTL. If provided, this number denotes the factor by which predicting the largest number token is worse than predicting the closest incorrect number token. E.g., with digit-level tokenization this factor is 9. Setting this to 1 will recover cross entropy. This argument is intended to handle irregular vocabs with large numerical token values.</p> <code>None</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    digit_level: bool = True,\n    reweigh: bool = True,\n    squash_factor: Optional[float] = None,\n):\n    \"\"\"\n    NTL constructor for the Wasserstein-based NTLoss.\n\n    Args:\n        tokenizer: Any HuggingFace tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        digit_level: Whether to ensure only digits are considered number tokens,\n            stabilizing training with NTL. Defaults to True. Used for most\n            experiments in the ICML paper.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n        squash_factor: The optional squashing factor for the NTL. If provided,\n            this number denotes the factor by which predicting the largest number\n            token is worse than predicting the closest incorrect number token.\n            E.g., with digit-level tokenization this factor is 9. Setting this\n            to 1 will recover cross entropy. This argument is intended to handle\n            irregular vocabs with large numerical token values.\n    \"\"\"\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=digit_level,\n        reweigh=reweigh,\n    )\n\n    self.squash_factor = squash_factor\n    self.setup_distance_lookup(squash_factor)\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLoss.setup_distance_lookup","title":"<code>setup_distance_lookup(squash_factor: Optional[float] = None) -&gt; None</code>","text":"<p>Set up a lookup table for the distances between the number tokens. Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token. If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9. NOTE: With a squashing factor of 1, this basically collapses to cross entropy.</p> <p>Parameters:</p> Name Type Description Default <code>squash_factor</code> <code>Optional[float]</code> <p>The optional squashing factor used.</p> <code>None</code> Source code in <code>ntloss/core.py</code> <pre><code>def setup_distance_lookup(\n    self,\n    squash_factor: Optional[float] = None,\n) -&gt; None:\n    \"\"\"\n    Set up a lookup table for the distances between the number tokens.\n    Use squash_factor to control by what factor the farthest number token is worse than the closest, incorrect number token.\n    If not squash_factor is not set: with 10 number tokens (0-9), the squashing factor is 9.\n    NOTE: With a squashing factor of 1, this basically collapses to cross entropy.\n\n    Args:\n        squash_factor: The optional squashing factor used.\n    \"\"\"\n\n    # Get token ids for number tokens\n    num_ids = torch.nonzero(self.is_number_token, as_tuple=True)[0]\n    # Create mapping from number token ids to their index in order of appearance in vocab:\n    # e.g. token \"3\" -&gt; id 519 -&gt; dist_idx 1, then abs dist to 3 for other NT values will be found in row/column 1\n    vocab_to_dist_idx = torch.full((self.vocab_size,), -1, dtype=torch.long)\n    # Use arange to ensure order of appearance\n    vocab_to_dist_idx[num_ids] = torch.arange(num_ids.size(0), dtype=torch.long)\n\n    # Build NxN abs-diff matrix\n    vals = self.number_values_dense.unsqueeze(0)  # (1 x N)\n    diff = torch.abs(vals - vals.t())  # (N x N)\n\n    if isinstance(squash_factor, Number):\n        assert squash_factor &gt; 1, (\n            f\"The squash factor can't be equal to or smaller than 1, please use a different squashing factor than {squash_factor}\"\n        )\n\n        # Mask out zeros to find the smallest nonzero diff\n        inf = torch.finfo(diff.dtype).max\n        diff_nonzero = diff.masked_fill(diff == 0, inf)\n        global_min_nz = diff_nonzero.min()\n        # Find largest diff\n        global_max = diff.max()\n\n        # Compute scaling factor based on indicated squash factor\n        scale = (squash_factor - 1) / (global_max - global_min_nz)\n        # Scale the absolute differences using scaling factor\n        lookup = 1 + (diff - global_min_nz) * scale\n        lookup[diff == 0] = 0.0\n\n    else:\n        lookup = diff\n\n    self.vocab_to_dist_idx = vocab_to_dist_idx\n    self.dist_lookup = lookup\n    self.max_dist = lookup.max()\n</code></pre>"},{"location":"api/core/#ntloss.core.NTLoss.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>Optional 2D tensor of BS x T with token-specific weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor OD if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: Optional 2D tensor of BS x T with token-specific weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            OD if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, loss_weights = self._prepare_number_token_targets(\n        labels, loss_weights, ignore_index\n    )\n    loss_weights = loss_weights.to(logits.dtype)\n    number_token_positions = ~torch.isnan(y)\n\n    # If no digit tokens in batch, or total of the relevant loss_weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or not loss_weights.any():\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(\n                labels, dtype=logits.dtype, device=labels.device\n            )\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    # apply softmax and get number labels\n    nt_logits = logits[:, :, self.is_number_token]\n    softmax_probs = F.softmax(nt_logits, dim=-1)\n\n    # get distance between the true numbers and all possible number values from lookup table\n    abs_diff = self.dist_lookup.to(dtype=logits.dtype, device=logits.device)[\n        self.vocab_to_dist_idx.to(device=labels.device)[\n            labels[number_token_positions]\n        ]\n    ]\n\n    # loss is the absolute difference weighted by the softmax probs\n    loss = (abs_diff * softmax_probs[number_token_positions]).sum(dim=-1)\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NumberLevelLoss","title":"<code>NumberLevelLoss</code>","text":"<p>               Bases: <code>NTLossDotProduct</code></p> <p>Calculate NTL on a per-number (rather than per-token) basis.</p> Source code in <code>ntloss/core.py</code> <pre><code>class NumberLevelLoss(NTLossDotProduct):\n    \"\"\"Calculate NTL on a per-number (rather than per-token) basis.\"\"\"\n\n    def __init__(\n        self,\n        tokenizer: PreTrainedTokenizer,\n        vocab_size: Optional[int] = None,\n        float_level: bool = False,\n        reweigh: bool = True,\n        max_number_length: int = 20,\n    ):\n        \"\"\"\n        NTL constructor for the number-level NTLoss.\n\n        Args:\n            tokenizer: Any HuggingFace tokenizer.\n            vocab_size: Optional user-provided vocab size. If not provided, the\n                tokenizer's vocab size is used.\n            float_level: Whether to calculate the loss for every float or every\n                integer in the sequence. For `12.34`, if float_level=False, two\n                loss terms will be calculated, respectively for `12` and `34`.\n                If float_level=True, a single `.` does not break the contiguity\n                of the identified number. Defaults to False.\n            reweigh: Whether to scale the NTL using the logit weight on\n                number tokens. Defaults to True.\n                NOTE: The ICML paper does *not* use this option which can lead to\n                incorrect loss if most mass is placed outside of the number tokens.\n                Using this will explode the NL-NTL in the current implementation,\n                so reweighing for the NL-NTL needs to be refined.\n            max_number_length: Maximum expected length of a number in tokens.\n                Used for precomputing power masks. Defaults to 20.\n\n        \"\"\"\n        # digit_level must be set to True.\n        super().__init__(\n            tokenizer=tokenizer,\n            vocab_size=vocab_size,\n            digit_level=True,\n            reweigh=reweigh,\n            loss_function=F.l1_loss,  # unused\n        )\n        self.float_level = float_level\n        dot_result = self.tokenizer.convert_tokens_to_ids(\".\")\n        # Ensure we get an int, not a list\n        self.dot: int = dot_result if isinstance(dot_result, int) else dot_result[0]\n\n        # Precompute powers of 10 for efficiency\n        self.max_number_length = max_number_length\n        self.powers_of_10 = torch.pow(\n            10.0, torch.arange(max_number_length, dtype=torch.float32)\n        )\n\n    def setup_max_dist(self):\n        \"\"\"\n        Due to the MAPE loss calculation, the max dist is limited to 1.0\n        \"\"\"\n        self.max_dist = torch.tensor(1.0)\n\n    def convert_digits_to_numbers(\n        self,\n        y: FloatTensor,\n        yhat: FloatTensor,\n        number_token_positions: BoolTensor,\n        labels: LongTensor,\n    ):\n        \"\"\"\n        Vectorized conversion of digit-level number tokens to number-level values.\n\n        Output convention:\n        - Only the *first digit* of each detected number span contains the full number.\n        - All other digits (and in float_level=True also the dot token) inside the span\n            are set to NaN and removed from number_token_positions.\n        - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\")\n        - float_level=True : a single '.' between digits is part of the span but contributes 0\n                            (12.34 -&gt; \"1234\" as integer-like concatenation)\n\n        Args:\n            y: (B, T) float, GT digit values at digit positions, NaN elsewhere\n            yhat: (B, T) float, predicted digit values at all positions\n            number_token_positions: (B, T) bool, True at digit positions\n            labels: (B, T) long, token ids\n\n        Returns:\n            (y_new, yhat_new, number_token_positions_new) at number-level\n        \"\"\"\n        B, T = y.shape\n        device = y.device\n        is_digit = number_token_positions  # (B, T)\n        if not is_digit.any():\n            return y, yhat, number_token_positions\n\n        # -------------------------------------------------------------------------\n        # 1) Decide which tokens are considered \"inside a number span\"\n        # -------------------------------------------------------------------------\n        # Base: digits are always in spans\n        in_number: BoolTensor = is_digit\n\n        if self.float_level:\n            is_dot = labels.eq(self.dot)  # (B, T)\n\n            # dot is part of a number span only if it is *between* digits: d . d\n            digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n            digit_prev[:, 1:] = is_digit[:, :-1]\n\n            digit_next = torch.zeros((B, T), dtype=torch.bool, device=device)\n            digit_next[:, :-1] = is_digit[:, 1:]\n\n            dot_between_digits = is_dot &amp; digit_prev &amp; digit_next\n\n            # In float mode, those dots count as \"in number\" (but contribute 0 later)\n            in_number = cast(BoolTensor, in_number | dot_between_digits)\n        else:\n            dot_between_digits = torch.zeros((B, T), dtype=torch.bool, device=device)\n\n        # -------------------------------------------------------------------------\n        # 2) Build a \"continuation\" mask: does position t continue a span from t-1?\n        # -------------------------------------------------------------------------\n        # If previous token is a digit =&gt; continuation for digits (and for dot-between-digits in float mode)\n        digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_prev[:, 1:] = is_digit[:, :-1]\n\n        if self.float_level:\n            is_dot = labels.eq(self.dot)\n\n            dot_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n            dot_prev[:, 1:] = is_dot[:, :-1]\n\n            digit_prev2 = torch.zeros((B, T), dtype=torch.bool, device=device)\n            if T &gt; 2:\n                digit_prev2[:, 2:] = is_digit[:, :-2]\n\n            # Continue if:\n            #  - previous is digit, OR\n            #  - previous is dot and the token before that is digit (digit . digit)\n            continues_span = digit_prev | (dot_prev &amp; digit_prev2)\n        else:\n            continues_span = digit_prev\n\n        # A span starts wherever we're \"in_number\" but not continuing a previous span\n        span_start = in_number &amp; ~continues_span\n\n        # -------------------------------------------------------------------------\n        # 3) Assign each in-number token a segment id (per batch element)\n        # -------------------------------------------------------------------------\n        # seg_id is 0 for non-number tokens, otherwise 1..K within each row\n        seg_id = torch.cumsum(span_start.to(torch.int32), dim=1)\n        seg_id = seg_id * in_number.to(torch.int32)  # zero out non-number tokens\n\n        # How many segments max per row? Needed for a stable \"global segment id\"\n        segs_per_row = seg_id.max(dim=1).values  # (B,)\n        max_segs = int(segs_per_row.max().item())\n        if max_segs == 0:\n            return y, yhat, number_token_positions\n\n        # Make segment ids unique across batch:\n        # global_seg = b * (max_segs + 1) + seg_id\n        stride = max_segs + 1\n        batch_base = (torch.arange(B, device=device, dtype=torch.int64) * stride).view(\n            B, 1\n        )\n        global_seg = batch_base + seg_id.to(torch.int64)  # (B, T), 0 means \"no segment\"\n\n        # First digit of each number span (used both for segment-local digit indexing\n        # and for writing the final number-level values back).\n        number_start = span_start &amp; is_digit  # (B, T)\n\n        # -------------------------------------------------------------------------\n        # 4) Compute per-digit exponent within each segment (not across the row)\n        # -------------------------------------------------------------------------\n        # Row-wide digit cumsum (1-based on digit positions).\n        digit_cumsum = torch.cumsum(is_digit.to(torch.int32), dim=1)\n\n        # Reuse segment ids as scatter/gather indices to stay fully vectorized.\n        total_segments = B * stride  # includes one \"non-segment\" bin per row\n        flat_seg = global_seg.view(-1)\n\n        # Total number of digits in each segment (dots excluded).\n        seg_digit_count = torch.zeros((total_segments,), device=device, dtype=torch.int32)\n        seg_digit_count.scatter_add_(0, flat_seg, is_digit.to(torch.int32).view(-1))\n\n        # Row digit count before the first digit of each segment.\n        seg_digit_offset = torch.zeros(\n            (total_segments,), device=device, dtype=torch.int32\n        )\n        seg_digit_offset.scatter_(\n            0,\n            global_seg[number_start],\n            (digit_cumsum[number_start] - 1).to(torch.int32),\n        )\n\n        # Segment-local 1-based digit index, then convert to base-10 exponent.\n        digit_idx_in_seg = digit_cumsum - seg_digit_offset[global_seg]\n        exponent = (seg_digit_count[global_seg] - digit_idx_in_seg).clamp_min(0).to(\n            torch.int64\n        )\n\n        # Keep exponents within our precomputed range (or assert if you prefer strict behavior)\n        exponent = exponent.clamp_max(self.max_number_length - 1)\n\n        pow10_y = self.powers_of_10.to(device=device, dtype=y.dtype)  # (L,)\n        scale_y = pow10_y[exponent]  # (B, T)\n        if yhat.dtype == y.dtype:\n            scale_yhat = scale_y\n        else:\n            scale_yhat = self.powers_of_10.to(device=device, dtype=yhat.dtype)[\n                exponent\n            ]\n\n        # -------------------------------------------------------------------------\n        # 5) Compute digit contributions and sum per segment via scatter_add\n        # -------------------------------------------------------------------------\n        # Only digits contribute; dots/non-number contribute 0.\n        y_contrib = torch.where(is_digit, y * scale_y, torch.zeros((), device=device, dtype=y.dtype))\n        yhat_contrib = torch.where(\n            is_digit, yhat * scale_yhat, torch.zeros((), device=device, dtype=yhat.dtype)\n        )\n\n        seg_sum_y = torch.zeros((total_segments,), device=device, dtype=y.dtype)\n        seg_sum_yhat = torch.zeros((total_segments,), device=device, dtype=yhat.dtype)\n        seg_sum_y.scatter_add_(0, flat_seg, y_contrib.view(-1))\n        seg_sum_yhat.scatter_add_(0, flat_seg, yhat_contrib.view(-1))\n\n        # -------------------------------------------------------------------------\n        # 6) Write segment sums back only at the *first digit* position of each span\n        # -------------------------------------------------------------------------\n        # Important: if float_level=True, span_start could be a dot (but we want first *digit*).\n\n        y_new = y.clone()\n        yhat_new = yhat.clone()\n\n        # Everything inside a span but not the start digit becomes NaN (incl. dots, other digits)\n        in_span_not_start = in_number &amp; ~number_start\n        y_new = y_new.masked_fill(in_span_not_start, float(\"nan\"))\n        yhat_new = yhat_new.masked_fill(in_span_not_start, float(\"nan\"))\n\n        # Fill starts with summed values\n        start_seg = global_seg[number_start]  # (N,)\n        y_new[number_start] = seg_sum_y[start_seg]\n        yhat_new[number_start] = seg_sum_yhat[start_seg]\n\n        # Mask now indicates number-level positions (one per number span)\n        number_token_positions_new = number_start\n\n        return y_new, yhat_new, number_token_positions_new\n\n    def forward(\n        self,\n        logits: FloatTensor,\n        labels: LongTensor,\n        loss_weights: Optional[Tensor] = None,\n        reduction: str = \"mean\",\n        ignore_index: int = -100,\n    ) -&gt; Tensor:\n        \"\"\"\n        Computes the NTL based on the dot product between token values and their probs.\n\n        Args:\n            logits: 3D Tensor of shape BS x T x V.\n            labels: 2D Tensor of shape BS x T.\n            loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n            reduction: Optional string specifying the reduction to apply to the\n                output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n            ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n        Returns:\n            Loss tensor\n                0-D if reduction==\"mean\"|\"sum\"\n                BS x T if reduction==\"none\"\n        \"\"\"\n        self._validate_inputs(logits, labels, loss_weights)\n\n        y, _ = self._prepare_number_token_targets(labels, loss_weights, ignore_index)\n        number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n        # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n        if not number_token_positions.any() or (\n            loss_weights is not None and not loss_weights.any()\n        ):\n            if (reduction == \"mean\") | (reduction == \"sum\"):\n                loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n            elif reduction == \"none\":\n                loss = torch.zeros_like(labels, dtype=logits.dtype)\n            else:\n                raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n            return loss\n\n        yhat = self._get_dot_product(logits=logits)\n\n        y, yhat, number_token_positions = self.convert_digits_to_numbers(\n            y, yhat, number_token_positions, labels\n        )\n        if loss_weights is None:\n            loss_weights = torch.ones_like(labels, dtype=logits.dtype)\n        loss_weights = loss_weights[number_token_positions]\n\n        # NOTE: Alternative could be to apply specified loss function to normalized yhat\n        # loss = self.loss_function(torch.div(\n        #     yhat[number_token_positions],\n        #     y[number_token_positions].clamp_min(torch.finfo(y.dtype).eps),\n        # ), torch.ones_like(yhat), reduction=\"none\")\n\n        y_num = y[number_token_positions]\n        yh_num = yhat[number_token_positions]\n        # Calculate symmetric MAPE which is bounded in [0, 1]\n        loss = (yh_num - y_num).abs() / (\n            yh_num.abs() + y_num.abs() + torch.finfo(y.dtype).eps\n        )\n\n        # If reweigh: compute weights for NTL based on logits\n        if self.reweigh:\n            loss = self.reweigh_fn(\n                logits=logits, loss=loss, number_token_positions=number_token_positions\n            )\n\n        loss = self._apply_reduction(\n            loss=loss,\n            reduction=reduction,\n            loss_weights=loss_weights,\n            number_token_positions=number_token_positions,\n            logits=logits,\n        )\n\n        return loss\n</code></pre>"},{"location":"api/core/#ntloss.core.NumberLevelLoss.__init__","title":"<code>__init__(tokenizer: PreTrainedTokenizer, vocab_size: Optional[int] = None, float_level: bool = False, reweigh: bool = True, max_number_length: int = 20)</code>","text":"<p>NTL constructor for the number-level NTLoss.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>PreTrainedTokenizer</code> <p>Any HuggingFace tokenizer.</p> required <code>vocab_size</code> <code>Optional[int]</code> <p>Optional user-provided vocab size. If not provided, the tokenizer's vocab size is used.</p> <code>None</code> <code>float_level</code> <code>bool</code> <p>Whether to calculate the loss for every float or every integer in the sequence. For <code>12.34</code>, if float_level=False, two loss terms will be calculated, respectively for <code>12</code> and <code>34</code>. If float_level=True, a single <code>.</code> does not break the contiguity of the identified number. Defaults to False.</p> <code>False</code> <code>reweigh</code> <code>bool</code> <p>Whether to scale the NTL using the logit weight on number tokens. Defaults to True. NOTE: The ICML paper does not use this option which can lead to incorrect loss if most mass is placed outside of the number tokens. Using this will explode the NL-NTL in the current implementation, so reweighing for the NL-NTL needs to be refined.</p> <code>True</code> <code>max_number_length</code> <code>int</code> <p>Maximum expected length of a number in tokens. Used for precomputing power masks. Defaults to 20.</p> <code>20</code> Source code in <code>ntloss/core.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: PreTrainedTokenizer,\n    vocab_size: Optional[int] = None,\n    float_level: bool = False,\n    reweigh: bool = True,\n    max_number_length: int = 20,\n):\n    \"\"\"\n    NTL constructor for the number-level NTLoss.\n\n    Args:\n        tokenizer: Any HuggingFace tokenizer.\n        vocab_size: Optional user-provided vocab size. If not provided, the\n            tokenizer's vocab size is used.\n        float_level: Whether to calculate the loss for every float or every\n            integer in the sequence. For `12.34`, if float_level=False, two\n            loss terms will be calculated, respectively for `12` and `34`.\n            If float_level=True, a single `.` does not break the contiguity\n            of the identified number. Defaults to False.\n        reweigh: Whether to scale the NTL using the logit weight on\n            number tokens. Defaults to True.\n            NOTE: The ICML paper does *not* use this option which can lead to\n            incorrect loss if most mass is placed outside of the number tokens.\n            Using this will explode the NL-NTL in the current implementation,\n            so reweighing for the NL-NTL needs to be refined.\n        max_number_length: Maximum expected length of a number in tokens.\n            Used for precomputing power masks. Defaults to 20.\n\n    \"\"\"\n    # digit_level must be set to True.\n    super().__init__(\n        tokenizer=tokenizer,\n        vocab_size=vocab_size,\n        digit_level=True,\n        reweigh=reweigh,\n        loss_function=F.l1_loss,  # unused\n    )\n    self.float_level = float_level\n    dot_result = self.tokenizer.convert_tokens_to_ids(\".\")\n    # Ensure we get an int, not a list\n    self.dot: int = dot_result if isinstance(dot_result, int) else dot_result[0]\n\n    # Precompute powers of 10 for efficiency\n    self.max_number_length = max_number_length\n    self.powers_of_10 = torch.pow(\n        10.0, torch.arange(max_number_length, dtype=torch.float32)\n    )\n</code></pre>"},{"location":"api/core/#ntloss.core.NumberLevelLoss.setup_max_dist","title":"<code>setup_max_dist()</code>","text":"<p>Due to the MAPE loss calculation, the max dist is limited to 1.0</p> Source code in <code>ntloss/core.py</code> <pre><code>def setup_max_dist(self):\n    \"\"\"\n    Due to the MAPE loss calculation, the max dist is limited to 1.0\n    \"\"\"\n    self.max_dist = torch.tensor(1.0)\n</code></pre>"},{"location":"api/core/#ntloss.core.NumberLevelLoss.convert_digits_to_numbers","title":"<code>convert_digits_to_numbers(y: FloatTensor, yhat: FloatTensor, number_token_positions: BoolTensor, labels: LongTensor)</code>","text":"<p>Vectorized conversion of digit-level number tokens to number-level values.</p> <p>Output convention: - Only the first digit of each detected number span contains the full number. - All other digits (and in float_level=True also the dot token) inside the span     are set to NaN and removed from number_token_positions. - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\") - float_level=True : a single '.' between digits is part of the span but contributes 0                     (12.34 -&gt; \"1234\" as integer-like concatenation)</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>FloatTensor</code> <p>(B, T) float, GT digit values at digit positions, NaN elsewhere</p> required <code>yhat</code> <code>FloatTensor</code> <p>(B, T) float, predicted digit values at all positions</p> required <code>number_token_positions</code> <code>BoolTensor</code> <p>(B, T) bool, True at digit positions</p> required <code>labels</code> <code>LongTensor</code> <p>(B, T) long, token ids</p> required <p>Returns:</p> Type Description <p>(y_new, yhat_new, number_token_positions_new) at number-level</p> Source code in <code>ntloss/core.py</code> <pre><code>def convert_digits_to_numbers(\n    self,\n    y: FloatTensor,\n    yhat: FloatTensor,\n    number_token_positions: BoolTensor,\n    labels: LongTensor,\n):\n    \"\"\"\n    Vectorized conversion of digit-level number tokens to number-level values.\n\n    Output convention:\n    - Only the *first digit* of each detected number span contains the full number.\n    - All other digits (and in float_level=True also the dot token) inside the span\n        are set to NaN and removed from number_token_positions.\n    - float_level=False: '.' breaks number spans (12.34 -&gt; \"12\" and \"34\")\n    - float_level=True : a single '.' between digits is part of the span but contributes 0\n                        (12.34 -&gt; \"1234\" as integer-like concatenation)\n\n    Args:\n        y: (B, T) float, GT digit values at digit positions, NaN elsewhere\n        yhat: (B, T) float, predicted digit values at all positions\n        number_token_positions: (B, T) bool, True at digit positions\n        labels: (B, T) long, token ids\n\n    Returns:\n        (y_new, yhat_new, number_token_positions_new) at number-level\n    \"\"\"\n    B, T = y.shape\n    device = y.device\n    is_digit = number_token_positions  # (B, T)\n    if not is_digit.any():\n        return y, yhat, number_token_positions\n\n    # -------------------------------------------------------------------------\n    # 1) Decide which tokens are considered \"inside a number span\"\n    # -------------------------------------------------------------------------\n    # Base: digits are always in spans\n    in_number: BoolTensor = is_digit\n\n    if self.float_level:\n        is_dot = labels.eq(self.dot)  # (B, T)\n\n        # dot is part of a number span only if it is *between* digits: d . d\n        digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_prev[:, 1:] = is_digit[:, :-1]\n\n        digit_next = torch.zeros((B, T), dtype=torch.bool, device=device)\n        digit_next[:, :-1] = is_digit[:, 1:]\n\n        dot_between_digits = is_dot &amp; digit_prev &amp; digit_next\n\n        # In float mode, those dots count as \"in number\" (but contribute 0 later)\n        in_number = cast(BoolTensor, in_number | dot_between_digits)\n    else:\n        dot_between_digits = torch.zeros((B, T), dtype=torch.bool, device=device)\n\n    # -------------------------------------------------------------------------\n    # 2) Build a \"continuation\" mask: does position t continue a span from t-1?\n    # -------------------------------------------------------------------------\n    # If previous token is a digit =&gt; continuation for digits (and for dot-between-digits in float mode)\n    digit_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n    digit_prev[:, 1:] = is_digit[:, :-1]\n\n    if self.float_level:\n        is_dot = labels.eq(self.dot)\n\n        dot_prev = torch.zeros((B, T), dtype=torch.bool, device=device)\n        dot_prev[:, 1:] = is_dot[:, :-1]\n\n        digit_prev2 = torch.zeros((B, T), dtype=torch.bool, device=device)\n        if T &gt; 2:\n            digit_prev2[:, 2:] = is_digit[:, :-2]\n\n        # Continue if:\n        #  - previous is digit, OR\n        #  - previous is dot and the token before that is digit (digit . digit)\n        continues_span = digit_prev | (dot_prev &amp; digit_prev2)\n    else:\n        continues_span = digit_prev\n\n    # A span starts wherever we're \"in_number\" but not continuing a previous span\n    span_start = in_number &amp; ~continues_span\n\n    # -------------------------------------------------------------------------\n    # 3) Assign each in-number token a segment id (per batch element)\n    # -------------------------------------------------------------------------\n    # seg_id is 0 for non-number tokens, otherwise 1..K within each row\n    seg_id = torch.cumsum(span_start.to(torch.int32), dim=1)\n    seg_id = seg_id * in_number.to(torch.int32)  # zero out non-number tokens\n\n    # How many segments max per row? Needed for a stable \"global segment id\"\n    segs_per_row = seg_id.max(dim=1).values  # (B,)\n    max_segs = int(segs_per_row.max().item())\n    if max_segs == 0:\n        return y, yhat, number_token_positions\n\n    # Make segment ids unique across batch:\n    # global_seg = b * (max_segs + 1) + seg_id\n    stride = max_segs + 1\n    batch_base = (torch.arange(B, device=device, dtype=torch.int64) * stride).view(\n        B, 1\n    )\n    global_seg = batch_base + seg_id.to(torch.int64)  # (B, T), 0 means \"no segment\"\n\n    # First digit of each number span (used both for segment-local digit indexing\n    # and for writing the final number-level values back).\n    number_start = span_start &amp; is_digit  # (B, T)\n\n    # -------------------------------------------------------------------------\n    # 4) Compute per-digit exponent within each segment (not across the row)\n    # -------------------------------------------------------------------------\n    # Row-wide digit cumsum (1-based on digit positions).\n    digit_cumsum = torch.cumsum(is_digit.to(torch.int32), dim=1)\n\n    # Reuse segment ids as scatter/gather indices to stay fully vectorized.\n    total_segments = B * stride  # includes one \"non-segment\" bin per row\n    flat_seg = global_seg.view(-1)\n\n    # Total number of digits in each segment (dots excluded).\n    seg_digit_count = torch.zeros((total_segments,), device=device, dtype=torch.int32)\n    seg_digit_count.scatter_add_(0, flat_seg, is_digit.to(torch.int32).view(-1))\n\n    # Row digit count before the first digit of each segment.\n    seg_digit_offset = torch.zeros(\n        (total_segments,), device=device, dtype=torch.int32\n    )\n    seg_digit_offset.scatter_(\n        0,\n        global_seg[number_start],\n        (digit_cumsum[number_start] - 1).to(torch.int32),\n    )\n\n    # Segment-local 1-based digit index, then convert to base-10 exponent.\n    digit_idx_in_seg = digit_cumsum - seg_digit_offset[global_seg]\n    exponent = (seg_digit_count[global_seg] - digit_idx_in_seg).clamp_min(0).to(\n        torch.int64\n    )\n\n    # Keep exponents within our precomputed range (or assert if you prefer strict behavior)\n    exponent = exponent.clamp_max(self.max_number_length - 1)\n\n    pow10_y = self.powers_of_10.to(device=device, dtype=y.dtype)  # (L,)\n    scale_y = pow10_y[exponent]  # (B, T)\n    if yhat.dtype == y.dtype:\n        scale_yhat = scale_y\n    else:\n        scale_yhat = self.powers_of_10.to(device=device, dtype=yhat.dtype)[\n            exponent\n        ]\n\n    # -------------------------------------------------------------------------\n    # 5) Compute digit contributions and sum per segment via scatter_add\n    # -------------------------------------------------------------------------\n    # Only digits contribute; dots/non-number contribute 0.\n    y_contrib = torch.where(is_digit, y * scale_y, torch.zeros((), device=device, dtype=y.dtype))\n    yhat_contrib = torch.where(\n        is_digit, yhat * scale_yhat, torch.zeros((), device=device, dtype=yhat.dtype)\n    )\n\n    seg_sum_y = torch.zeros((total_segments,), device=device, dtype=y.dtype)\n    seg_sum_yhat = torch.zeros((total_segments,), device=device, dtype=yhat.dtype)\n    seg_sum_y.scatter_add_(0, flat_seg, y_contrib.view(-1))\n    seg_sum_yhat.scatter_add_(0, flat_seg, yhat_contrib.view(-1))\n\n    # -------------------------------------------------------------------------\n    # 6) Write segment sums back only at the *first digit* position of each span\n    # -------------------------------------------------------------------------\n    # Important: if float_level=True, span_start could be a dot (but we want first *digit*).\n\n    y_new = y.clone()\n    yhat_new = yhat.clone()\n\n    # Everything inside a span but not the start digit becomes NaN (incl. dots, other digits)\n    in_span_not_start = in_number &amp; ~number_start\n    y_new = y_new.masked_fill(in_span_not_start, float(\"nan\"))\n    yhat_new = yhat_new.masked_fill(in_span_not_start, float(\"nan\"))\n\n    # Fill starts with summed values\n    start_seg = global_seg[number_start]  # (N,)\n    y_new[number_start] = seg_sum_y[start_seg]\n    yhat_new[number_start] = seg_sum_yhat[start_seg]\n\n    # Mask now indicates number-level positions (one per number span)\n    number_token_positions_new = number_start\n\n    return y_new, yhat_new, number_token_positions_new\n</code></pre>"},{"location":"api/core/#ntloss.core.NumberLevelLoss.forward","title":"<code>forward(logits: FloatTensor, labels: LongTensor, loss_weights: Optional[Tensor] = None, reduction: str = 'mean', ignore_index: int = -100) -&gt; Tensor</code>","text":"<p>Computes the NTL based on the dot product between token values and their probs.</p> <p>Parameters:</p> Name Type Description Default <code>logits</code> <code>FloatTensor</code> <p>3D Tensor of shape BS x T x V.</p> required <code>labels</code> <code>LongTensor</code> <p>2D Tensor of shape BS x T.</p> required <code>loss_weights</code> <code>Optional[Tensor]</code> <p>2D Optional tensor of BS x T with token-wise loss weights.</p> <code>None</code> <code>reduction</code> <code>str</code> <p>Optional string specifying the reduction to apply to the output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".</p> <code>'mean'</code> <code>ignore_index</code> <code>int</code> <p>The token ID to ignore in the labels. Defaults to -100.</p> <code>-100</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss tensor 0-D if reduction==\"mean\"|\"sum\" BS x T if reduction==\"none\"</p> Source code in <code>ntloss/core.py</code> <pre><code>def forward(\n    self,\n    logits: FloatTensor,\n    labels: LongTensor,\n    loss_weights: Optional[Tensor] = None,\n    reduction: str = \"mean\",\n    ignore_index: int = -100,\n) -&gt; Tensor:\n    \"\"\"\n    Computes the NTL based on the dot product between token values and their probs.\n\n    Args:\n        logits: 3D Tensor of shape BS x T x V.\n        labels: 2D Tensor of shape BS x T.\n        loss_weights: 2D Optional tensor of BS x T with token-wise loss weights.\n        reduction: Optional string specifying the reduction to apply to the\n            output. Defaults to \"mean\", options are \"mean\", \"sum\", \"none\".\n        ignore_index: The token ID to ignore in the labels. Defaults to -100.\n\n    Returns:\n        Loss tensor\n            0-D if reduction==\"mean\"|\"sum\"\n            BS x T if reduction==\"none\"\n    \"\"\"\n    self._validate_inputs(logits, labels, loss_weights)\n\n    y, _ = self._prepare_number_token_targets(labels, loss_weights, ignore_index)\n    number_token_positions = cast(BoolTensor, ~torch.isnan(y))\n\n    # If no digit tokens in batch, or total of the relevant loss weights is zero, no need for upcoming calculations\n    if not number_token_positions.any() or (\n        loss_weights is not None and not loss_weights.any()\n    ):\n        if (reduction == \"mean\") | (reduction == \"sum\"):\n            loss = torch.tensor(0, dtype=logits.dtype, device=labels.device)\n        elif reduction == \"none\":\n            loss = torch.zeros_like(labels, dtype=logits.dtype)\n        else:\n            raise ValueError(f\"{reduction} is not a valid value for reduction\")\n\n        return loss\n\n    yhat = self._get_dot_product(logits=logits)\n\n    y, yhat, number_token_positions = self.convert_digits_to_numbers(\n        y, yhat, number_token_positions, labels\n    )\n    if loss_weights is None:\n        loss_weights = torch.ones_like(labels, dtype=logits.dtype)\n    loss_weights = loss_weights[number_token_positions]\n\n    # NOTE: Alternative could be to apply specified loss function to normalized yhat\n    # loss = self.loss_function(torch.div(\n    #     yhat[number_token_positions],\n    #     y[number_token_positions].clamp_min(torch.finfo(y.dtype).eps),\n    # ), torch.ones_like(yhat), reduction=\"none\")\n\n    y_num = y[number_token_positions]\n    yh_num = yhat[number_token_positions]\n    # Calculate symmetric MAPE which is bounded in [0, 1]\n    loss = (yh_num - y_num).abs() / (\n        yh_num.abs() + y_num.abs() + torch.finfo(y.dtype).eps\n    )\n\n    # If reweigh: compute weights for NTL based on logits\n    if self.reweigh:\n        loss = self.reweigh_fn(\n            logits=logits, loss=loss, number_token_positions=number_token_positions\n        )\n\n    loss = self._apply_reduction(\n        loss=loss,\n        reduction=reduction,\n        loss_weights=loss_weights,\n        number_token_positions=number_token_positions,\n        logits=logits,\n    )\n\n    return loss\n</code></pre>"},{"location":"api/utils/","title":"ntloss.utils","text":""},{"location":"api/utils/#ntloss.utils","title":"<code>ntloss.utils</code>","text":""},{"location":"api/utils/#ntloss.utils.is_number","title":"<code>is_number(something: Any, finite: bool = True) -&gt; bool</code>","text":"<p>Check whether something is convertible to a float</p> <p>Parameters:</p> Name Type Description Default <code>something</code> <code>Any</code> <p>something to test for float casting.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not it's a number</p> Source code in <code>ntloss/utils.py</code> <pre><code>def is_number(something: Any, finite: bool = True) -&gt; bool:\n    \"\"\"Check whether something is convertible to a float\n\n    Args:\n        something: something to test for float casting.\n\n    Returns:\n        Whether or not it's a number\n    \"\"\"\n    try:\n        f = float(something)\n        if finite and not math.isfinite(f):\n            return False\n        return True\n    except ValueError:\n        return False\n</code></pre>"}]}